<?xml version="1.0"?>
<doc>
    <assembly>
        <name>FilterLib</name>
    </assembly>
    <members>
        <member name="T:FilterLib.FilterClass">
            <summary>
            The FilterClass class provides a CLS compliant, MWArray interface to the MATLAB
            functions contained in the files:
            <newpara></newpara>
            E:\Logiciel\Matlab_r2015a\bin\estnoisem.m
            <newpara></newpara>
            E:\Logiciel\Matlab_r2015a\bin\filter.m
            <newpara></newpara>
            E:\Logiciel\Matlab_r2015a\bin\FiltrePassBas.m
            <newpara></newpara>
            E:\Logiciel\Matlab_r2015a\bin\irfft.m
            <newpara></newpara>
            E:\Logiciel\Matlab_r2015a\bin\specsub.m
            <newpara></newpara>
            E:\Logiciel\Matlab_r2015a\bin\specsubm.m
            <newpara></newpara>
            E:\Logiciel\Matlab_r2015a\bin\ssubmmse.m
            </summary>
            <remarks>
            @Version 0.0
            </remarks>
        </member>
        <member name="M:FilterLib.FilterClass.#cctor">
            <summary internal= "true">
            The static constructor instantiates and initializes the MATLAB runtime instance.
            </summary>
        </member>
        <member name="M:FilterLib.FilterClass.#ctor">
            <summary>
            Constructs a new instance of the FilterClass class.
            </summary>
        </member>
        <member name="M:FilterLib.FilterClass.Finalize">
            <summary internal= "true">
            Class destructor called by the CLR garbage collector.
            </summary>
        </member>
        <member name="M:FilterLib.FilterClass.Dispose">
            <summary>
            Frees the native resources associated with this object
            </summary>
        </member>
        <member name="M:FilterLib.FilterClass.Dispose(System.Boolean)">
            <summary internal= "true">
            Internal dispose function
            </summary>
        </member>
        <member name="M:FilterLib.FilterClass.estnoisem">
             <summary>
             Provides a single output, 0-input MWArrayinterface to the estnoisem MATLAB
             function.
             </summary>
             <remarks>
             M-Documentation:
             ESTNOISEM - estimate noise spectrum using minimum statistics
             Usage:    ninc=round(0.016*fs);      frame increment [fs=sample frequency]
             ovf=2;                     overlap factor
             f=rfft(enframe(s,hanning(ovf*ninc,'periodic'),ninc),ovf*ninc,2);
             f=f.*conj(f);              convert to power spectrum
             x=estnoisem(f,ninc/fs);    estimate the noise power spectrum
             Inputs:
             yf      input power spectra (one row per frame)
             tz      frame increment in seconds
             Alternatively, the input state from a previous call (see below)
             pp      algorithm parameters [optional]
             Outputs:
             x       estimated noise power spectra (one row per frame)
             zo      output state
             xs      estimated std error of x (one row per frame)
             xs seems often to be an underestimate by a factor of 2 or 3
             The algorithm parameters are defined in reference [1] from which equation
             numbers are given in parentheses. They are as follows:
             pp.taca         (11): smoothing time constant for alpha_c [0.0449 seconds]
             pp.tamax        (3): max smoothing time constant [0.392 seconds]
             pp.taminh       (3): min smoothing time constant (upper limit) [0.0133 seconds]
             pp.tpfall       (12): time constant for P to fall [0.064 seconds]
             pp.tbmax        (20): max smoothing time constant [0.0717 seconds]
             pp.qeqmin       (23): minimum value of Qeq [2]
             pp.qeqmax       max value of Qeq per frame [14]
             pp.av           (23)+13 lines: fudge factor for bc calculation  [2.12]
             pp.td           time to take minimum over [1.536 seconds]
             pp.nu           number of subwindows to use [3]
             pp.qith         Q-inverse thresholds to select maximum noise slope [0.03 0.05
             0.06 Inf ]
             pp.nsmdb        corresponding noise slope thresholds in dB/second   [47 31.4 15.7
             4.1]
             Example use:      y=enframe(s,w,ni);                     divide speech signal
             s(n) into
             overlapping frames using window w(n)
             yf=rfft(y,nf,2);                       take fourier transform
             dp=estnoisem(yf.*conj(yf),tinc);       estimate the noise
             If convenient, you can call estnoisem in chunks of arbitrary size. Thus the
             following are equivalent:
             (a) dp=estnoisem(yp(1:300),tinc);
             (b) [dp(1:100),z]=estnoisem(yp(1:100),tinc);
             [dp(101:200),z]=estnoisem(yp(101:200),z);
             [dp(201:300),z]=estnoisem(yp(201:300),z);
             </remarks>
             <returns>An MWArray containing the first output argument.</returns>
            
        </member>
        <member name="M:FilterLib.FilterClass.estnoisem(MathWorks.MATLAB.NET.Arrays.MWArray)">
             <summary>
             Provides a single output, 1-input MWArrayinterface to the estnoisem MATLAB
             function.
             </summary>
             <remarks>
             M-Documentation:
             ESTNOISEM - estimate noise spectrum using minimum statistics
             Usage:    ninc=round(0.016*fs);      frame increment [fs=sample frequency]
             ovf=2;                     overlap factor
             f=rfft(enframe(s,hanning(ovf*ninc,'periodic'),ninc),ovf*ninc,2);
             f=f.*conj(f);              convert to power spectrum
             x=estnoisem(f,ninc/fs);    estimate the noise power spectrum
             Inputs:
             yf      input power spectra (one row per frame)
             tz      frame increment in seconds
             Alternatively, the input state from a previous call (see below)
             pp      algorithm parameters [optional]
             Outputs:
             x       estimated noise power spectra (one row per frame)
             zo      output state
             xs      estimated std error of x (one row per frame)
             xs seems often to be an underestimate by a factor of 2 or 3
             The algorithm parameters are defined in reference [1] from which equation
             numbers are given in parentheses. They are as follows:
             pp.taca         (11): smoothing time constant for alpha_c [0.0449 seconds]
             pp.tamax        (3): max smoothing time constant [0.392 seconds]
             pp.taminh       (3): min smoothing time constant (upper limit) [0.0133 seconds]
             pp.tpfall       (12): time constant for P to fall [0.064 seconds]
             pp.tbmax        (20): max smoothing time constant [0.0717 seconds]
             pp.qeqmin       (23): minimum value of Qeq [2]
             pp.qeqmax       max value of Qeq per frame [14]
             pp.av           (23)+13 lines: fudge factor for bc calculation  [2.12]
             pp.td           time to take minimum over [1.536 seconds]
             pp.nu           number of subwindows to use [3]
             pp.qith         Q-inverse thresholds to select maximum noise slope [0.03 0.05
             0.06 Inf ]
             pp.nsmdb        corresponding noise slope thresholds in dB/second   [47 31.4 15.7
             4.1]
             Example use:      y=enframe(s,w,ni);                     divide speech signal
             s(n) into
             overlapping frames using window w(n)
             yf=rfft(y,nf,2);                       take fourier transform
             dp=estnoisem(yf.*conj(yf),tinc);       estimate the noise
             If convenient, you can call estnoisem in chunks of arbitrary size. Thus the
             following are equivalent:
             (a) dp=estnoisem(yp(1:300),tinc);
             (b) [dp(1:100),z]=estnoisem(yp(1:100),tinc);
             [dp(101:200),z]=estnoisem(yp(101:200),z);
             [dp(201:300),z]=estnoisem(yp(201:300),z);
             </remarks>
             <param name="yf">Input argument #1</param>
             <returns>An MWArray containing the first output argument.</returns>
            
        </member>
        <member name="M:FilterLib.FilterClass.estnoisem(MathWorks.MATLAB.NET.Arrays.MWArray,MathWorks.MATLAB.NET.Arrays.MWArray)">
             <summary>
             Provides a single output, 2-input MWArrayinterface to the estnoisem MATLAB
             function.
             </summary>
             <remarks>
             M-Documentation:
             ESTNOISEM - estimate noise spectrum using minimum statistics
             Usage:    ninc=round(0.016*fs);      frame increment [fs=sample frequency]
             ovf=2;                     overlap factor
             f=rfft(enframe(s,hanning(ovf*ninc,'periodic'),ninc),ovf*ninc,2);
             f=f.*conj(f);              convert to power spectrum
             x=estnoisem(f,ninc/fs);    estimate the noise power spectrum
             Inputs:
             yf      input power spectra (one row per frame)
             tz      frame increment in seconds
             Alternatively, the input state from a previous call (see below)
             pp      algorithm parameters [optional]
             Outputs:
             x       estimated noise power spectra (one row per frame)
             zo      output state
             xs      estimated std error of x (one row per frame)
             xs seems often to be an underestimate by a factor of 2 or 3
             The algorithm parameters are defined in reference [1] from which equation
             numbers are given in parentheses. They are as follows:
             pp.taca         (11): smoothing time constant for alpha_c [0.0449 seconds]
             pp.tamax        (3): max smoothing time constant [0.392 seconds]
             pp.taminh       (3): min smoothing time constant (upper limit) [0.0133 seconds]
             pp.tpfall       (12): time constant for P to fall [0.064 seconds]
             pp.tbmax        (20): max smoothing time constant [0.0717 seconds]
             pp.qeqmin       (23): minimum value of Qeq [2]
             pp.qeqmax       max value of Qeq per frame [14]
             pp.av           (23)+13 lines: fudge factor for bc calculation  [2.12]
             pp.td           time to take minimum over [1.536 seconds]
             pp.nu           number of subwindows to use [3]
             pp.qith         Q-inverse thresholds to select maximum noise slope [0.03 0.05
             0.06 Inf ]
             pp.nsmdb        corresponding noise slope thresholds in dB/second   [47 31.4 15.7
             4.1]
             Example use:      y=enframe(s,w,ni);                     divide speech signal
             s(n) into
             overlapping frames using window w(n)
             yf=rfft(y,nf,2);                       take fourier transform
             dp=estnoisem(yf.*conj(yf),tinc);       estimate the noise
             If convenient, you can call estnoisem in chunks of arbitrary size. Thus the
             following are equivalent:
             (a) dp=estnoisem(yp(1:300),tinc);
             (b) [dp(1:100),z]=estnoisem(yp(1:100),tinc);
             [dp(101:200),z]=estnoisem(yp(101:200),z);
             [dp(201:300),z]=estnoisem(yp(201:300),z);
             </remarks>
             <param name="yf">Input argument #1</param>
             <param name="tz">Input argument #2</param>
             <returns>An MWArray containing the first output argument.</returns>
            
        </member>
        <member name="M:FilterLib.FilterClass.estnoisem(MathWorks.MATLAB.NET.Arrays.MWArray,MathWorks.MATLAB.NET.Arrays.MWArray,MathWorks.MATLAB.NET.Arrays.MWArray)">
             <summary>
             Provides a single output, 3-input MWArrayinterface to the estnoisem MATLAB
             function.
             </summary>
             <remarks>
             M-Documentation:
             ESTNOISEM - estimate noise spectrum using minimum statistics
             Usage:    ninc=round(0.016*fs);      frame increment [fs=sample frequency]
             ovf=2;                     overlap factor
             f=rfft(enframe(s,hanning(ovf*ninc,'periodic'),ninc),ovf*ninc,2);
             f=f.*conj(f);              convert to power spectrum
             x=estnoisem(f,ninc/fs);    estimate the noise power spectrum
             Inputs:
             yf      input power spectra (one row per frame)
             tz      frame increment in seconds
             Alternatively, the input state from a previous call (see below)
             pp      algorithm parameters [optional]
             Outputs:
             x       estimated noise power spectra (one row per frame)
             zo      output state
             xs      estimated std error of x (one row per frame)
             xs seems often to be an underestimate by a factor of 2 or 3
             The algorithm parameters are defined in reference [1] from which equation
             numbers are given in parentheses. They are as follows:
             pp.taca         (11): smoothing time constant for alpha_c [0.0449 seconds]
             pp.tamax        (3): max smoothing time constant [0.392 seconds]
             pp.taminh       (3): min smoothing time constant (upper limit) [0.0133 seconds]
             pp.tpfall       (12): time constant for P to fall [0.064 seconds]
             pp.tbmax        (20): max smoothing time constant [0.0717 seconds]
             pp.qeqmin       (23): minimum value of Qeq [2]
             pp.qeqmax       max value of Qeq per frame [14]
             pp.av           (23)+13 lines: fudge factor for bc calculation  [2.12]
             pp.td           time to take minimum over [1.536 seconds]
             pp.nu           number of subwindows to use [3]
             pp.qith         Q-inverse thresholds to select maximum noise slope [0.03 0.05
             0.06 Inf ]
             pp.nsmdb        corresponding noise slope thresholds in dB/second   [47 31.4 15.7
             4.1]
             Example use:      y=enframe(s,w,ni);                     divide speech signal
             s(n) into
             overlapping frames using window w(n)
             yf=rfft(y,nf,2);                       take fourier transform
             dp=estnoisem(yf.*conj(yf),tinc);       estimate the noise
             If convenient, you can call estnoisem in chunks of arbitrary size. Thus the
             following are equivalent:
             (a) dp=estnoisem(yp(1:300),tinc);
             (b) [dp(1:100),z]=estnoisem(yp(1:100),tinc);
             [dp(101:200),z]=estnoisem(yp(101:200),z);
             [dp(201:300),z]=estnoisem(yp(201:300),z);
             </remarks>
             <param name="yf">Input argument #1</param>
             <param name="tz">Input argument #2</param>
             <param name="pp">Input argument #3</param>
             <returns>An MWArray containing the first output argument.</returns>
            
        </member>
        <member name="M:FilterLib.FilterClass.estnoisem(System.Int32)">
             <summary>
             Provides the standard 0-input MWArray interface to the estnoisem MATLAB function.
             </summary>
             <remarks>
             M-Documentation:
             ESTNOISEM - estimate noise spectrum using minimum statistics
             Usage:    ninc=round(0.016*fs);      frame increment [fs=sample frequency]
             ovf=2;                     overlap factor
             f=rfft(enframe(s,hanning(ovf*ninc,'periodic'),ninc),ovf*ninc,2);
             f=f.*conj(f);              convert to power spectrum
             x=estnoisem(f,ninc/fs);    estimate the noise power spectrum
             Inputs:
             yf      input power spectra (one row per frame)
             tz      frame increment in seconds
             Alternatively, the input state from a previous call (see below)
             pp      algorithm parameters [optional]
             Outputs:
             x       estimated noise power spectra (one row per frame)
             zo      output state
             xs      estimated std error of x (one row per frame)
             xs seems often to be an underestimate by a factor of 2 or 3
             The algorithm parameters are defined in reference [1] from which equation
             numbers are given in parentheses. They are as follows:
             pp.taca         (11): smoothing time constant for alpha_c [0.0449 seconds]
             pp.tamax        (3): max smoothing time constant [0.392 seconds]
             pp.taminh       (3): min smoothing time constant (upper limit) [0.0133 seconds]
             pp.tpfall       (12): time constant for P to fall [0.064 seconds]
             pp.tbmax        (20): max smoothing time constant [0.0717 seconds]
             pp.qeqmin       (23): minimum value of Qeq [2]
             pp.qeqmax       max value of Qeq per frame [14]
             pp.av           (23)+13 lines: fudge factor for bc calculation  [2.12]
             pp.td           time to take minimum over [1.536 seconds]
             pp.nu           number of subwindows to use [3]
             pp.qith         Q-inverse thresholds to select maximum noise slope [0.03 0.05
             0.06 Inf ]
             pp.nsmdb        corresponding noise slope thresholds in dB/second   [47 31.4 15.7
             4.1]
             Example use:      y=enframe(s,w,ni);                     divide speech signal
             s(n) into
             overlapping frames using window w(n)
             yf=rfft(y,nf,2);                       take fourier transform
             dp=estnoisem(yf.*conj(yf),tinc);       estimate the noise
             If convenient, you can call estnoisem in chunks of arbitrary size. Thus the
             following are equivalent:
             (a) dp=estnoisem(yp(1:300),tinc);
             (b) [dp(1:100),z]=estnoisem(yp(1:100),tinc);
             [dp(101:200),z]=estnoisem(yp(101:200),z);
             [dp(201:300),z]=estnoisem(yp(201:300),z);
             </remarks>
             <param name="numArgsOut">The number of output arguments to return.</param>
             <returns>An Array of length "numArgsOut" containing the output
             arguments.</returns>
            
        </member>
        <member name="M:FilterLib.FilterClass.estnoisem(System.Int32,MathWorks.MATLAB.NET.Arrays.MWArray)">
             <summary>
             Provides the standard 1-input MWArray interface to the estnoisem MATLAB function.
             </summary>
             <remarks>
             M-Documentation:
             ESTNOISEM - estimate noise spectrum using minimum statistics
             Usage:    ninc=round(0.016*fs);      frame increment [fs=sample frequency]
             ovf=2;                     overlap factor
             f=rfft(enframe(s,hanning(ovf*ninc,'periodic'),ninc),ovf*ninc,2);
             f=f.*conj(f);              convert to power spectrum
             x=estnoisem(f,ninc/fs);    estimate the noise power spectrum
             Inputs:
             yf      input power spectra (one row per frame)
             tz      frame increment in seconds
             Alternatively, the input state from a previous call (see below)
             pp      algorithm parameters [optional]
             Outputs:
             x       estimated noise power spectra (one row per frame)
             zo      output state
             xs      estimated std error of x (one row per frame)
             xs seems often to be an underestimate by a factor of 2 or 3
             The algorithm parameters are defined in reference [1] from which equation
             numbers are given in parentheses. They are as follows:
             pp.taca         (11): smoothing time constant for alpha_c [0.0449 seconds]
             pp.tamax        (3): max smoothing time constant [0.392 seconds]
             pp.taminh       (3): min smoothing time constant (upper limit) [0.0133 seconds]
             pp.tpfall       (12): time constant for P to fall [0.064 seconds]
             pp.tbmax        (20): max smoothing time constant [0.0717 seconds]
             pp.qeqmin       (23): minimum value of Qeq [2]
             pp.qeqmax       max value of Qeq per frame [14]
             pp.av           (23)+13 lines: fudge factor for bc calculation  [2.12]
             pp.td           time to take minimum over [1.536 seconds]
             pp.nu           number of subwindows to use [3]
             pp.qith         Q-inverse thresholds to select maximum noise slope [0.03 0.05
             0.06 Inf ]
             pp.nsmdb        corresponding noise slope thresholds in dB/second   [47 31.4 15.7
             4.1]
             Example use:      y=enframe(s,w,ni);                     divide speech signal
             s(n) into
             overlapping frames using window w(n)
             yf=rfft(y,nf,2);                       take fourier transform
             dp=estnoisem(yf.*conj(yf),tinc);       estimate the noise
             If convenient, you can call estnoisem in chunks of arbitrary size. Thus the
             following are equivalent:
             (a) dp=estnoisem(yp(1:300),tinc);
             (b) [dp(1:100),z]=estnoisem(yp(1:100),tinc);
             [dp(101:200),z]=estnoisem(yp(101:200),z);
             [dp(201:300),z]=estnoisem(yp(201:300),z);
             </remarks>
             <param name="numArgsOut">The number of output arguments to return.</param>
             <param name="yf">Input argument #1</param>
             <returns>An Array of length "numArgsOut" containing the output
             arguments.</returns>
            
        </member>
        <member name="M:FilterLib.FilterClass.estnoisem(System.Int32,MathWorks.MATLAB.NET.Arrays.MWArray,MathWorks.MATLAB.NET.Arrays.MWArray)">
             <summary>
             Provides the standard 2-input MWArray interface to the estnoisem MATLAB function.
             </summary>
             <remarks>
             M-Documentation:
             ESTNOISEM - estimate noise spectrum using minimum statistics
             Usage:    ninc=round(0.016*fs);      frame increment [fs=sample frequency]
             ovf=2;                     overlap factor
             f=rfft(enframe(s,hanning(ovf*ninc,'periodic'),ninc),ovf*ninc,2);
             f=f.*conj(f);              convert to power spectrum
             x=estnoisem(f,ninc/fs);    estimate the noise power spectrum
             Inputs:
             yf      input power spectra (one row per frame)
             tz      frame increment in seconds
             Alternatively, the input state from a previous call (see below)
             pp      algorithm parameters [optional]
             Outputs:
             x       estimated noise power spectra (one row per frame)
             zo      output state
             xs      estimated std error of x (one row per frame)
             xs seems often to be an underestimate by a factor of 2 or 3
             The algorithm parameters are defined in reference [1] from which equation
             numbers are given in parentheses. They are as follows:
             pp.taca         (11): smoothing time constant for alpha_c [0.0449 seconds]
             pp.tamax        (3): max smoothing time constant [0.392 seconds]
             pp.taminh       (3): min smoothing time constant (upper limit) [0.0133 seconds]
             pp.tpfall       (12): time constant for P to fall [0.064 seconds]
             pp.tbmax        (20): max smoothing time constant [0.0717 seconds]
             pp.qeqmin       (23): minimum value of Qeq [2]
             pp.qeqmax       max value of Qeq per frame [14]
             pp.av           (23)+13 lines: fudge factor for bc calculation  [2.12]
             pp.td           time to take minimum over [1.536 seconds]
             pp.nu           number of subwindows to use [3]
             pp.qith         Q-inverse thresholds to select maximum noise slope [0.03 0.05
             0.06 Inf ]
             pp.nsmdb        corresponding noise slope thresholds in dB/second   [47 31.4 15.7
             4.1]
             Example use:      y=enframe(s,w,ni);                     divide speech signal
             s(n) into
             overlapping frames using window w(n)
             yf=rfft(y,nf,2);                       take fourier transform
             dp=estnoisem(yf.*conj(yf),tinc);       estimate the noise
             If convenient, you can call estnoisem in chunks of arbitrary size. Thus the
             following are equivalent:
             (a) dp=estnoisem(yp(1:300),tinc);
             (b) [dp(1:100),z]=estnoisem(yp(1:100),tinc);
             [dp(101:200),z]=estnoisem(yp(101:200),z);
             [dp(201:300),z]=estnoisem(yp(201:300),z);
             </remarks>
             <param name="numArgsOut">The number of output arguments to return.</param>
             <param name="yf">Input argument #1</param>
             <param name="tz">Input argument #2</param>
             <returns>An Array of length "numArgsOut" containing the output
             arguments.</returns>
            
        </member>
        <member name="M:FilterLib.FilterClass.estnoisem(System.Int32,MathWorks.MATLAB.NET.Arrays.MWArray,MathWorks.MATLAB.NET.Arrays.MWArray,MathWorks.MATLAB.NET.Arrays.MWArray)">
             <summary>
             Provides the standard 3-input MWArray interface to the estnoisem MATLAB function.
             </summary>
             <remarks>
             M-Documentation:
             ESTNOISEM - estimate noise spectrum using minimum statistics
             Usage:    ninc=round(0.016*fs);      frame increment [fs=sample frequency]
             ovf=2;                     overlap factor
             f=rfft(enframe(s,hanning(ovf*ninc,'periodic'),ninc),ovf*ninc,2);
             f=f.*conj(f);              convert to power spectrum
             x=estnoisem(f,ninc/fs);    estimate the noise power spectrum
             Inputs:
             yf      input power spectra (one row per frame)
             tz      frame increment in seconds
             Alternatively, the input state from a previous call (see below)
             pp      algorithm parameters [optional]
             Outputs:
             x       estimated noise power spectra (one row per frame)
             zo      output state
             xs      estimated std error of x (one row per frame)
             xs seems often to be an underestimate by a factor of 2 or 3
             The algorithm parameters are defined in reference [1] from which equation
             numbers are given in parentheses. They are as follows:
             pp.taca         (11): smoothing time constant for alpha_c [0.0449 seconds]
             pp.tamax        (3): max smoothing time constant [0.392 seconds]
             pp.taminh       (3): min smoothing time constant (upper limit) [0.0133 seconds]
             pp.tpfall       (12): time constant for P to fall [0.064 seconds]
             pp.tbmax        (20): max smoothing time constant [0.0717 seconds]
             pp.qeqmin       (23): minimum value of Qeq [2]
             pp.qeqmax       max value of Qeq per frame [14]
             pp.av           (23)+13 lines: fudge factor for bc calculation  [2.12]
             pp.td           time to take minimum over [1.536 seconds]
             pp.nu           number of subwindows to use [3]
             pp.qith         Q-inverse thresholds to select maximum noise slope [0.03 0.05
             0.06 Inf ]
             pp.nsmdb        corresponding noise slope thresholds in dB/second   [47 31.4 15.7
             4.1]
             Example use:      y=enframe(s,w,ni);                     divide speech signal
             s(n) into
             overlapping frames using window w(n)
             yf=rfft(y,nf,2);                       take fourier transform
             dp=estnoisem(yf.*conj(yf),tinc);       estimate the noise
             If convenient, you can call estnoisem in chunks of arbitrary size. Thus the
             following are equivalent:
             (a) dp=estnoisem(yp(1:300),tinc);
             (b) [dp(1:100),z]=estnoisem(yp(1:100),tinc);
             [dp(101:200),z]=estnoisem(yp(101:200),z);
             [dp(201:300),z]=estnoisem(yp(201:300),z);
             </remarks>
             <param name="numArgsOut">The number of output arguments to return.</param>
             <param name="yf">Input argument #1</param>
             <param name="tz">Input argument #2</param>
             <param name="pp">Input argument #3</param>
             <returns>An Array of length "numArgsOut" containing the output
             arguments.</returns>
            
        </member>
        <member name="M:FilterLib.FilterClass.estnoisem(System.Int32,MathWorks.MATLAB.NET.Arrays.MWArray[]@,MathWorks.MATLAB.NET.Arrays.MWArray[])">
             <summary>
             Provides an interface for the estnoisem function in which the input and output
             arguments are specified as an array of MWArrays.
             </summary>
             <remarks>
             This method will allocate and return by reference the output argument
             array.<newpara></newpara>
             M-Documentation:
             ESTNOISEM - estimate noise spectrum using minimum statistics
             Usage:    ninc=round(0.016*fs);      frame increment [fs=sample frequency]
             ovf=2;                     overlap factor
             f=rfft(enframe(s,hanning(ovf*ninc,'periodic'),ninc),ovf*ninc,2);
             f=f.*conj(f);              convert to power spectrum
             x=estnoisem(f,ninc/fs);    estimate the noise power spectrum
             Inputs:
             yf      input power spectra (one row per frame)
             tz      frame increment in seconds
             Alternatively, the input state from a previous call (see below)
             pp      algorithm parameters [optional]
             Outputs:
             x       estimated noise power spectra (one row per frame)
             zo      output state
             xs      estimated std error of x (one row per frame)
             xs seems often to be an underestimate by a factor of 2 or 3
             The algorithm parameters are defined in reference [1] from which equation
             numbers are given in parentheses. They are as follows:
             pp.taca         (11): smoothing time constant for alpha_c [0.0449 seconds]
             pp.tamax        (3): max smoothing time constant [0.392 seconds]
             pp.taminh       (3): min smoothing time constant (upper limit) [0.0133 seconds]
             pp.tpfall       (12): time constant for P to fall [0.064 seconds]
             pp.tbmax        (20): max smoothing time constant [0.0717 seconds]
             pp.qeqmin       (23): minimum value of Qeq [2]
             pp.qeqmax       max value of Qeq per frame [14]
             pp.av           (23)+13 lines: fudge factor for bc calculation  [2.12]
             pp.td           time to take minimum over [1.536 seconds]
             pp.nu           number of subwindows to use [3]
             pp.qith         Q-inverse thresholds to select maximum noise slope [0.03 0.05
             0.06 Inf ]
             pp.nsmdb        corresponding noise slope thresholds in dB/second   [47 31.4 15.7
             4.1]
             Example use:      y=enframe(s,w,ni);                     divide speech signal
             s(n) into
             overlapping frames using window w(n)
             yf=rfft(y,nf,2);                       take fourier transform
             dp=estnoisem(yf.*conj(yf),tinc);       estimate the noise
             If convenient, you can call estnoisem in chunks of arbitrary size. Thus the
             following are equivalent:
             (a) dp=estnoisem(yp(1:300),tinc);
             (b) [dp(1:100),z]=estnoisem(yp(1:100),tinc);
             [dp(101:200),z]=estnoisem(yp(101:200),z);
             [dp(201:300),z]=estnoisem(yp(201:300),z);
             </remarks>
             <param name="numArgsOut">The number of output arguments to return</param>
             <param name= "argsOut">Array of MWArray output arguments</param>
             <param name= "argsIn">Array of MWArray input arguments</param>
            
        </member>
        <member name="M:FilterLib.FilterClass.filter">
             <summary>
             Provides a single output, 0-input MWArrayinterface to the filter MATLAB function.
             </summary>
             <remarks>
             </remarks>
             <returns>An MWArray containing the first output argument.</returns>
            
        </member>
        <member name="M:FilterLib.FilterClass.filter(MathWorks.MATLAB.NET.Arrays.MWArray)">
             <summary>
             Provides a single output, 1-input MWArrayinterface to the filter MATLAB function.
             </summary>
             <remarks>
             </remarks>
             <param name="dir">Input argument #1</param>
             <returns>An MWArray containing the first output argument.</returns>
            
        </member>
        <member name="M:FilterLib.FilterClass.filter(System.Int32)">
             <summary>
             Provides the standard 0-input MWArray interface to the filter MATLAB function.
             </summary>
             <remarks>
             </remarks>
             <param name="numArgsOut">The number of output arguments to return.</param>
             <returns>An Array of length "numArgsOut" containing the output
             arguments.</returns>
            
        </member>
        <member name="M:FilterLib.FilterClass.filter(System.Int32,MathWorks.MATLAB.NET.Arrays.MWArray)">
             <summary>
             Provides the standard 1-input MWArray interface to the filter MATLAB function.
             </summary>
             <remarks>
             </remarks>
             <param name="numArgsOut">The number of output arguments to return.</param>
             <param name="dir">Input argument #1</param>
             <returns>An Array of length "numArgsOut" containing the output
             arguments.</returns>
            
        </member>
        <member name="M:FilterLib.FilterClass.filter(System.Int32,MathWorks.MATLAB.NET.Arrays.MWArray[]@,MathWorks.MATLAB.NET.Arrays.MWArray[])">
             <summary>
             Provides an interface for the filter function in which the input and output
             arguments are specified as an array of MWArrays.
             </summary>
             <remarks>
             This method will allocate and return by reference the output argument
             array.<newpara></newpara>
             </remarks>
             <param name="numArgsOut">The number of output arguments to return</param>
             <param name= "argsOut">Array of MWArray output arguments</param>
             <param name= "argsIn">Array of MWArray input arguments</param>
            
        </member>
        <member name="M:FilterLib.FilterClass.FiltrePassBas">
             <summary>
             Provides a single output, 0-input MWArrayinterface to the FiltrePassBas MATLAB
             function.
             </summary>
             <remarks>
             </remarks>
             <returns>An MWArray containing the first output argument.</returns>
            
        </member>
        <member name="M:FilterLib.FilterClass.FiltrePassBas(MathWorks.MATLAB.NET.Arrays.MWArray)">
             <summary>
             Provides a single output, 1-input MWArrayinterface to the FiltrePassBas MATLAB
             function.
             </summary>
             <remarks>
             </remarks>
             <param name="x">Input argument #1</param>
             <returns>An MWArray containing the first output argument.</returns>
            
        </member>
        <member name="M:FilterLib.FilterClass.FiltrePassBas(MathWorks.MATLAB.NET.Arrays.MWArray,MathWorks.MATLAB.NET.Arrays.MWArray)">
             <summary>
             Provides a single output, 2-input MWArrayinterface to the FiltrePassBas MATLAB
             function.
             </summary>
             <remarks>
             </remarks>
             <param name="x">Input argument #1</param>
             <param name="fs">Input argument #2</param>
             <returns>An MWArray containing the first output argument.</returns>
            
        </member>
        <member name="M:FilterLib.FilterClass.FiltrePassBas(System.Int32)">
             <summary>
             Provides the standard 0-input MWArray interface to the FiltrePassBas MATLAB
             function.
             </summary>
             <remarks>
             </remarks>
             <param name="numArgsOut">The number of output arguments to return.</param>
             <returns>An Array of length "numArgsOut" containing the output
             arguments.</returns>
            
        </member>
        <member name="M:FilterLib.FilterClass.FiltrePassBas(System.Int32,MathWorks.MATLAB.NET.Arrays.MWArray)">
             <summary>
             Provides the standard 1-input MWArray interface to the FiltrePassBas MATLAB
             function.
             </summary>
             <remarks>
             </remarks>
             <param name="numArgsOut">The number of output arguments to return.</param>
             <param name="x">Input argument #1</param>
             <returns>An Array of length "numArgsOut" containing the output
             arguments.</returns>
            
        </member>
        <member name="M:FilterLib.FilterClass.FiltrePassBas(System.Int32,MathWorks.MATLAB.NET.Arrays.MWArray,MathWorks.MATLAB.NET.Arrays.MWArray)">
             <summary>
             Provides the standard 2-input MWArray interface to the FiltrePassBas MATLAB
             function.
             </summary>
             <remarks>
             </remarks>
             <param name="numArgsOut">The number of output arguments to return.</param>
             <param name="x">Input argument #1</param>
             <param name="fs">Input argument #2</param>
             <returns>An Array of length "numArgsOut" containing the output
             arguments.</returns>
            
        </member>
        <member name="M:FilterLib.FilterClass.FiltrePassBas(System.Int32,MathWorks.MATLAB.NET.Arrays.MWArray[]@,MathWorks.MATLAB.NET.Arrays.MWArray[])">
             <summary>
             Provides an interface for the FiltrePassBas function in which the input and
             output
             arguments are specified as an array of MWArrays.
             </summary>
             <remarks>
             This method will allocate and return by reference the output argument
             array.<newpara></newpara>
             </remarks>
             <param name="numArgsOut">The number of output arguments to return</param>
             <param name= "argsOut">Array of MWArray output arguments</param>
             <param name= "argsIn">Array of MWArray input arguments</param>
            
        </member>
        <member name="M:FilterLib.FilterClass.irfft">
             <summary>
             Provides a single output, 0-input MWArrayinterface to the irfft MATLAB function.
             </summary>
             <remarks>
             M-Documentation:
             IRFFT    Inverse fft of a conjugate symmetric spectrum X=(Y,N,D)
             Inputs:  Y(M)   The first half of a complex spectrum
             N      The number of output points to generate (default: 2M-2)
             D      The dimension along which to perorm the transform
             (default: first non-singleton dimension of Y)
             Outputs: X(N)   Real inverse dft of Y
             This routine calculates the inverse DFT of a conjugate-symmetric to give a
             real-valued
             output of dimension N. Only the first half of the spectrum need be supplied: if N
             is even,
             this includes the Nyquist term and is of dimension M=N/2 + 1 whereas if N is odd
             then there is
             no Nyquist term and the input is of dimension M=(N+1)/2.
             Note that the default value of N is always even so that N must be given
             explicitly
             if it is odd.
             See also the forward transform: RFFT
             </remarks>
             <returns>An MWArray containing the first output argument.</returns>
            
        </member>
        <member name="M:FilterLib.FilterClass.irfft(MathWorks.MATLAB.NET.Arrays.MWArray)">
             <summary>
             Provides a single output, 1-input MWArrayinterface to the irfft MATLAB function.
             </summary>
             <remarks>
             M-Documentation:
             IRFFT    Inverse fft of a conjugate symmetric spectrum X=(Y,N,D)
             Inputs:  Y(M)   The first half of a complex spectrum
             N      The number of output points to generate (default: 2M-2)
             D      The dimension along which to perorm the transform
             (default: first non-singleton dimension of Y)
             Outputs: X(N)   Real inverse dft of Y
             This routine calculates the inverse DFT of a conjugate-symmetric to give a
             real-valued
             output of dimension N. Only the first half of the spectrum need be supplied: if N
             is even,
             this includes the Nyquist term and is of dimension M=N/2 + 1 whereas if N is odd
             then there is
             no Nyquist term and the input is of dimension M=(N+1)/2.
             Note that the default value of N is always even so that N must be given
             explicitly
             if it is odd.
             See also the forward transform: RFFT
             </remarks>
             <param name="y">Input argument #1</param>
             <returns>An MWArray containing the first output argument.</returns>
            
        </member>
        <member name="M:FilterLib.FilterClass.irfft(MathWorks.MATLAB.NET.Arrays.MWArray,MathWorks.MATLAB.NET.Arrays.MWArray)">
             <summary>
             Provides a single output, 2-input MWArrayinterface to the irfft MATLAB function.
             </summary>
             <remarks>
             M-Documentation:
             IRFFT    Inverse fft of a conjugate symmetric spectrum X=(Y,N,D)
             Inputs:  Y(M)   The first half of a complex spectrum
             N      The number of output points to generate (default: 2M-2)
             D      The dimension along which to perorm the transform
             (default: first non-singleton dimension of Y)
             Outputs: X(N)   Real inverse dft of Y
             This routine calculates the inverse DFT of a conjugate-symmetric to give a
             real-valued
             output of dimension N. Only the first half of the spectrum need be supplied: if N
             is even,
             this includes the Nyquist term and is of dimension M=N/2 + 1 whereas if N is odd
             then there is
             no Nyquist term and the input is of dimension M=(N+1)/2.
             Note that the default value of N is always even so that N must be given
             explicitly
             if it is odd.
             See also the forward transform: RFFT
             </remarks>
             <param name="y">Input argument #1</param>
             <param name="n">Input argument #2</param>
             <returns>An MWArray containing the first output argument.</returns>
            
        </member>
        <member name="M:FilterLib.FilterClass.irfft(MathWorks.MATLAB.NET.Arrays.MWArray,MathWorks.MATLAB.NET.Arrays.MWArray,MathWorks.MATLAB.NET.Arrays.MWArray)">
             <summary>
             Provides a single output, 3-input MWArrayinterface to the irfft MATLAB function.
             </summary>
             <remarks>
             M-Documentation:
             IRFFT    Inverse fft of a conjugate symmetric spectrum X=(Y,N,D)
             Inputs:  Y(M)   The first half of a complex spectrum
             N      The number of output points to generate (default: 2M-2)
             D      The dimension along which to perorm the transform
             (default: first non-singleton dimension of Y)
             Outputs: X(N)   Real inverse dft of Y
             This routine calculates the inverse DFT of a conjugate-symmetric to give a
             real-valued
             output of dimension N. Only the first half of the spectrum need be supplied: if N
             is even,
             this includes the Nyquist term and is of dimension M=N/2 + 1 whereas if N is odd
             then there is
             no Nyquist term and the input is of dimension M=(N+1)/2.
             Note that the default value of N is always even so that N must be given
             explicitly
             if it is odd.
             See also the forward transform: RFFT
             </remarks>
             <param name="y">Input argument #1</param>
             <param name="n">Input argument #2</param>
             <param name="d">Input argument #3</param>
             <returns>An MWArray containing the first output argument.</returns>
            
        </member>
        <member name="M:FilterLib.FilterClass.irfft(System.Int32)">
             <summary>
             Provides the standard 0-input MWArray interface to the irfft MATLAB function.
             </summary>
             <remarks>
             M-Documentation:
             IRFFT    Inverse fft of a conjugate symmetric spectrum X=(Y,N,D)
             Inputs:  Y(M)   The first half of a complex spectrum
             N      The number of output points to generate (default: 2M-2)
             D      The dimension along which to perorm the transform
             (default: first non-singleton dimension of Y)
             Outputs: X(N)   Real inverse dft of Y
             This routine calculates the inverse DFT of a conjugate-symmetric to give a
             real-valued
             output of dimension N. Only the first half of the spectrum need be supplied: if N
             is even,
             this includes the Nyquist term and is of dimension M=N/2 + 1 whereas if N is odd
             then there is
             no Nyquist term and the input is of dimension M=(N+1)/2.
             Note that the default value of N is always even so that N must be given
             explicitly
             if it is odd.
             See also the forward transform: RFFT
             </remarks>
             <param name="numArgsOut">The number of output arguments to return.</param>
             <returns>An Array of length "numArgsOut" containing the output
             arguments.</returns>
            
        </member>
        <member name="M:FilterLib.FilterClass.irfft(System.Int32,MathWorks.MATLAB.NET.Arrays.MWArray)">
             <summary>
             Provides the standard 1-input MWArray interface to the irfft MATLAB function.
             </summary>
             <remarks>
             M-Documentation:
             IRFFT    Inverse fft of a conjugate symmetric spectrum X=(Y,N,D)
             Inputs:  Y(M)   The first half of a complex spectrum
             N      The number of output points to generate (default: 2M-2)
             D      The dimension along which to perorm the transform
             (default: first non-singleton dimension of Y)
             Outputs: X(N)   Real inverse dft of Y
             This routine calculates the inverse DFT of a conjugate-symmetric to give a
             real-valued
             output of dimension N. Only the first half of the spectrum need be supplied: if N
             is even,
             this includes the Nyquist term and is of dimension M=N/2 + 1 whereas if N is odd
             then there is
             no Nyquist term and the input is of dimension M=(N+1)/2.
             Note that the default value of N is always even so that N must be given
             explicitly
             if it is odd.
             See also the forward transform: RFFT
             </remarks>
             <param name="numArgsOut">The number of output arguments to return.</param>
             <param name="y">Input argument #1</param>
             <returns>An Array of length "numArgsOut" containing the output
             arguments.</returns>
            
        </member>
        <member name="M:FilterLib.FilterClass.irfft(System.Int32,MathWorks.MATLAB.NET.Arrays.MWArray,MathWorks.MATLAB.NET.Arrays.MWArray)">
             <summary>
             Provides the standard 2-input MWArray interface to the irfft MATLAB function.
             </summary>
             <remarks>
             M-Documentation:
             IRFFT    Inverse fft of a conjugate symmetric spectrum X=(Y,N,D)
             Inputs:  Y(M)   The first half of a complex spectrum
             N      The number of output points to generate (default: 2M-2)
             D      The dimension along which to perorm the transform
             (default: first non-singleton dimension of Y)
             Outputs: X(N)   Real inverse dft of Y
             This routine calculates the inverse DFT of a conjugate-symmetric to give a
             real-valued
             output of dimension N. Only the first half of the spectrum need be supplied: if N
             is even,
             this includes the Nyquist term and is of dimension M=N/2 + 1 whereas if N is odd
             then there is
             no Nyquist term and the input is of dimension M=(N+1)/2.
             Note that the default value of N is always even so that N must be given
             explicitly
             if it is odd.
             See also the forward transform: RFFT
             </remarks>
             <param name="numArgsOut">The number of output arguments to return.</param>
             <param name="y">Input argument #1</param>
             <param name="n">Input argument #2</param>
             <returns>An Array of length "numArgsOut" containing the output
             arguments.</returns>
            
        </member>
        <member name="M:FilterLib.FilterClass.irfft(System.Int32,MathWorks.MATLAB.NET.Arrays.MWArray,MathWorks.MATLAB.NET.Arrays.MWArray,MathWorks.MATLAB.NET.Arrays.MWArray)">
             <summary>
             Provides the standard 3-input MWArray interface to the irfft MATLAB function.
             </summary>
             <remarks>
             M-Documentation:
             IRFFT    Inverse fft of a conjugate symmetric spectrum X=(Y,N,D)
             Inputs:  Y(M)   The first half of a complex spectrum
             N      The number of output points to generate (default: 2M-2)
             D      The dimension along which to perorm the transform
             (default: first non-singleton dimension of Y)
             Outputs: X(N)   Real inverse dft of Y
             This routine calculates the inverse DFT of a conjugate-symmetric to give a
             real-valued
             output of dimension N. Only the first half of the spectrum need be supplied: if N
             is even,
             this includes the Nyquist term and is of dimension M=N/2 + 1 whereas if N is odd
             then there is
             no Nyquist term and the input is of dimension M=(N+1)/2.
             Note that the default value of N is always even so that N must be given
             explicitly
             if it is odd.
             See also the forward transform: RFFT
             </remarks>
             <param name="numArgsOut">The number of output arguments to return.</param>
             <param name="y">Input argument #1</param>
             <param name="n">Input argument #2</param>
             <param name="d">Input argument #3</param>
             <returns>An Array of length "numArgsOut" containing the output
             arguments.</returns>
            
        </member>
        <member name="M:FilterLib.FilterClass.irfft(System.Int32,MathWorks.MATLAB.NET.Arrays.MWArray[]@,MathWorks.MATLAB.NET.Arrays.MWArray[])">
             <summary>
             Provides an interface for the irfft function in which the input and output
             arguments are specified as an array of MWArrays.
             </summary>
             <remarks>
             This method will allocate and return by reference the output argument
             array.<newpara></newpara>
             M-Documentation:
             IRFFT    Inverse fft of a conjugate symmetric spectrum X=(Y,N,D)
             Inputs:  Y(M)   The first half of a complex spectrum
             N      The number of output points to generate (default: 2M-2)
             D      The dimension along which to perorm the transform
             (default: first non-singleton dimension of Y)
             Outputs: X(N)   Real inverse dft of Y
             This routine calculates the inverse DFT of a conjugate-symmetric to give a
             real-valued
             output of dimension N. Only the first half of the spectrum need be supplied: if N
             is even,
             this includes the Nyquist term and is of dimension M=N/2 + 1 whereas if N is odd
             then there is
             no Nyquist term and the input is of dimension M=(N+1)/2.
             Note that the default value of N is always even so that N must be given
             explicitly
             if it is odd.
             See also the forward transform: RFFT
             </remarks>
             <param name="numArgsOut">The number of output arguments to return</param>
             <param name= "argsOut">Array of MWArray output arguments</param>
             <param name= "argsIn">Array of MWArray input arguments</param>
            
        </member>
        <member name="M:FilterLib.FilterClass.specsub">
             <summary>
             Provides a single output, 0-input MWArrayinterface to the specsub MATLAB
             function.
             </summary>
             <remarks>
             M-Documentation:
             SPECSUB performs speech enhancement using spectral subtraction [SS,ZO]=(S,FSZ,P)
             Usage: (1) y=specsub(x,fs);      enhance the speech using default parameters
             Inputs:
             si      input speech signal
             fsz     sample frequency in Hz
             Alternatively, the input state from a previous call (see below)
             pp      algorithm parameters [optional]
             Outputs:
             ss        output enhanced speech
             gg(t,f,i) selected time-frequency values (see pp.tf below)
             tt        centre of frames (in seconds)
             ff        centre of frequency bins (in Hz)
             zo        output state (or the 2nd argument if gg,tt,ff are omitted)
             The algorithm operation is controlled by a small number of parameters:
             pp.of             overlap factor = (fft length)/(frame increment) [2]
             pp.ti             desired frame increment [0.016 seconds]
             pp.ri             set to 1 to round ti to the nearest power of 2 samples [0]
             pp.g              subtraction domain: 1=magnitude, 2=power [1]
             pp.e              gain exponent [1]
             pp.am             max oversubtraction factor [3]
             pp.b              max noise attenutaion in power domain [0.01]
             pp.al             SNR for oversubtraction=am (set this to Inf for fixed a) [-5
             dB]
             pp.ah             SNR for oversubtraction=1 [20 dB]
             pp.ne             noise estimation: 0=min statistics, 1=MMSE [0]
             pp.bt             threshold for binary gain or -1 for continuous gain [-1]
             pp.mx             input mixture gain [0]
             pp.gh             maximum gain for noise floor [1]
             pp.rf             round output signal to an exact number of frames [0]
             pp.tf             selects time-frequency planes to output in the gg() variable
             ['g']
             'i' = input power spectrum
             'I' = input complex spectrum
             'n' = noise power spectrum
             'g' = gain
             'o' = output power spectrum
             'O' = output complex spectrum
             Following [1], the magnitude-domain gain in each time-frequency bin is given by
             gain=mx+(1-mx)*max((1-(a*N/X)^(g/2))^(e/g),min(gh,(b*N/X)^(e/2)))
             where N and X are the powers of the noise and noisy speech respectively.
             The oversubtraction factor varies linearly between a=am for a frame SNR of al
             down to
             a=1 for a frame SNR of ah. To obtain a fixed value of a for all values of SNR,
             set al=Inf.
             Common exponent combinations are:
             g=1  e=1    Magnitude Domain spectral subtraction
             g=2  e=1    Power Domain spectral subtraction
             g=2  e=2    Wiener filtering
             Many authors use the parameters alpha=a^(g/2), beta=b^(g/2) and gamma2=e/g
             instead of a, b and e
             but this increases interdependence amongst the parameters.
             If bt>=0 then the max(...) expression above is thresholded to become 0 or 1.
             In addition it is possible to specify parameters for the noise estimation
             algorithm
             which implements reference [2] or [3] according to the setting of pp.ne
             Minimum statistics noise estimate [2]: pp.ne=0 
             pp.taca         (11): smoothing time constant for alpha_c [0.0449 seconds]
             pp.tamax        (3): max smoothing time constant [0.392 seconds]
             pp.taminh       (3): min smoothing time constant (upper limit) [0.0133 seconds]
             pp.tpfall       (12): time constant for P to fall [0.064 seconds]
             pp.tbmax        (20): max smoothing time constant [0.0717 seconds]
             pp.qeqmin       (23): minimum value of Qeq [2]
             pp.qeqmax       max value of Qeq per frame [14]
             pp.av           (23)+13 lines: fudge factor for bc calculation  [2.12]
             pp.td           time to take minimum over [1.536 seconds]
             pp.nu           number of subwindows to use [3]
             pp.qith         Q-inverse thresholds to select maximum noise slope [0.03 0.05
             0.06 Inf ]
             pp.nsmdb        corresponding noise slope thresholds in dB/second   [47 31.4 15.7
             4.1]
             MMSE noise estimate [3]: pp.ne=1 
             pp.tax         smoothing time constant for noise power estimate [0.0717
             seconds](8)
             pp.tap         smoothing time constant for smoothed speech prob [0.152
             seconds](23)
             pp.psthr       threshold for smoothed speech probability [0.99] (24)
             pp.pnsaf       noise probability safety value [0.01] (24)
             pp.pspri       prior speech probability [0.5] (18)
             pp.asnr        active SNR in dB [15] (18)
             pp.psini       initial speech probability [0.5] (23)
             pp.tavini      assumed speech absent time at start [0.064 seconds]
             If convenient, you can call specsub in chunks of arbitrary size. Thus the
             following are equivalent:
             (a) y=specsub(s,fs);
             (b) [y1,z]=specsub(s(1:1000),fs);
             [y2,z]=specsub(s(1001:2000),z);
             y3=specsub(s(2001:end),z);
             y=[y1; y2; y3];
             If the number of output arguments is either 2 or 5, the last partial frame of
             samples will
             be retained for overlap adding with the output from the next call to specsub().
             See also ssubmmse() for an alternative gain function
             Refs:
             [1] M. Berouti, R. Schwartz and J. Makhoul
             Enhancement of speech corrupted by acoustic noise
             Proc IEEE ICASSP, 1979, 4, 208-211
             [2] Rainer Martin.
             Noise power spectral density estimation based on optimal smoothing and minimum
             statistics.
             IEEE Trans. Speech and Audio Processing, 9(5):504-512, July 2001.
             [3] Gerkmann, T. &amp; Hendriks, R. C.
             Unbiased MMSE-Based Noise Power Estimation With Low Complexity and Low Tracking
             Delay
             IEEE Trans Audio, Speech, Language Processing, 2012, 20, 1383-1393
             </remarks>
             <returns>An MWArray containing the first output argument.</returns>
            
        </member>
        <member name="M:FilterLib.FilterClass.specsub(MathWorks.MATLAB.NET.Arrays.MWArray)">
             <summary>
             Provides a single output, 1-input MWArrayinterface to the specsub MATLAB
             function.
             </summary>
             <remarks>
             M-Documentation:
             SPECSUB performs speech enhancement using spectral subtraction [SS,ZO]=(S,FSZ,P)
             Usage: (1) y=specsub(x,fs);      enhance the speech using default parameters
             Inputs:
             si      input speech signal
             fsz     sample frequency in Hz
             Alternatively, the input state from a previous call (see below)
             pp      algorithm parameters [optional]
             Outputs:
             ss        output enhanced speech
             gg(t,f,i) selected time-frequency values (see pp.tf below)
             tt        centre of frames (in seconds)
             ff        centre of frequency bins (in Hz)
             zo        output state (or the 2nd argument if gg,tt,ff are omitted)
             The algorithm operation is controlled by a small number of parameters:
             pp.of             overlap factor = (fft length)/(frame increment) [2]
             pp.ti             desired frame increment [0.016 seconds]
             pp.ri             set to 1 to round ti to the nearest power of 2 samples [0]
             pp.g              subtraction domain: 1=magnitude, 2=power [1]
             pp.e              gain exponent [1]
             pp.am             max oversubtraction factor [3]
             pp.b              max noise attenutaion in power domain [0.01]
             pp.al             SNR for oversubtraction=am (set this to Inf for fixed a) [-5
             dB]
             pp.ah             SNR for oversubtraction=1 [20 dB]
             pp.ne             noise estimation: 0=min statistics, 1=MMSE [0]
             pp.bt             threshold for binary gain or -1 for continuous gain [-1]
             pp.mx             input mixture gain [0]
             pp.gh             maximum gain for noise floor [1]
             pp.rf             round output signal to an exact number of frames [0]
             pp.tf             selects time-frequency planes to output in the gg() variable
             ['g']
             'i' = input power spectrum
             'I' = input complex spectrum
             'n' = noise power spectrum
             'g' = gain
             'o' = output power spectrum
             'O' = output complex spectrum
             Following [1], the magnitude-domain gain in each time-frequency bin is given by
             gain=mx+(1-mx)*max((1-(a*N/X)^(g/2))^(e/g),min(gh,(b*N/X)^(e/2)))
             where N and X are the powers of the noise and noisy speech respectively.
             The oversubtraction factor varies linearly between a=am for a frame SNR of al
             down to
             a=1 for a frame SNR of ah. To obtain a fixed value of a for all values of SNR,
             set al=Inf.
             Common exponent combinations are:
             g=1  e=1    Magnitude Domain spectral subtraction
             g=2  e=1    Power Domain spectral subtraction
             g=2  e=2    Wiener filtering
             Many authors use the parameters alpha=a^(g/2), beta=b^(g/2) and gamma2=e/g
             instead of a, b and e
             but this increases interdependence amongst the parameters.
             If bt>=0 then the max(...) expression above is thresholded to become 0 or 1.
             In addition it is possible to specify parameters for the noise estimation
             algorithm
             which implements reference [2] or [3] according to the setting of pp.ne
             Minimum statistics noise estimate [2]: pp.ne=0 
             pp.taca         (11): smoothing time constant for alpha_c [0.0449 seconds]
             pp.tamax        (3): max smoothing time constant [0.392 seconds]
             pp.taminh       (3): min smoothing time constant (upper limit) [0.0133 seconds]
             pp.tpfall       (12): time constant for P to fall [0.064 seconds]
             pp.tbmax        (20): max smoothing time constant [0.0717 seconds]
             pp.qeqmin       (23): minimum value of Qeq [2]
             pp.qeqmax       max value of Qeq per frame [14]
             pp.av           (23)+13 lines: fudge factor for bc calculation  [2.12]
             pp.td           time to take minimum over [1.536 seconds]
             pp.nu           number of subwindows to use [3]
             pp.qith         Q-inverse thresholds to select maximum noise slope [0.03 0.05
             0.06 Inf ]
             pp.nsmdb        corresponding noise slope thresholds in dB/second   [47 31.4 15.7
             4.1]
             MMSE noise estimate [3]: pp.ne=1 
             pp.tax         smoothing time constant for noise power estimate [0.0717
             seconds](8)
             pp.tap         smoothing time constant for smoothed speech prob [0.152
             seconds](23)
             pp.psthr       threshold for smoothed speech probability [0.99] (24)
             pp.pnsaf       noise probability safety value [0.01] (24)
             pp.pspri       prior speech probability [0.5] (18)
             pp.asnr        active SNR in dB [15] (18)
             pp.psini       initial speech probability [0.5] (23)
             pp.tavini      assumed speech absent time at start [0.064 seconds]
             If convenient, you can call specsub in chunks of arbitrary size. Thus the
             following are equivalent:
             (a) y=specsub(s,fs);
             (b) [y1,z]=specsub(s(1:1000),fs);
             [y2,z]=specsub(s(1001:2000),z);
             y3=specsub(s(2001:end),z);
             y=[y1; y2; y3];
             If the number of output arguments is either 2 or 5, the last partial frame of
             samples will
             be retained for overlap adding with the output from the next call to specsub().
             See also ssubmmse() for an alternative gain function
             Refs:
             [1] M. Berouti, R. Schwartz and J. Makhoul
             Enhancement of speech corrupted by acoustic noise
             Proc IEEE ICASSP, 1979, 4, 208-211
             [2] Rainer Martin.
             Noise power spectral density estimation based on optimal smoothing and minimum
             statistics.
             IEEE Trans. Speech and Audio Processing, 9(5):504-512, July 2001.
             [3] Gerkmann, T. &amp; Hendriks, R. C.
             Unbiased MMSE-Based Noise Power Estimation With Low Complexity and Low Tracking
             Delay
             IEEE Trans Audio, Speech, Language Processing, 2012, 20, 1383-1393
             </remarks>
             <param name="si">Input argument #1</param>
             <returns>An MWArray containing the first output argument.</returns>
            
        </member>
        <member name="M:FilterLib.FilterClass.specsub(MathWorks.MATLAB.NET.Arrays.MWArray,MathWorks.MATLAB.NET.Arrays.MWArray)">
             <summary>
             Provides a single output, 2-input MWArrayinterface to the specsub MATLAB
             function.
             </summary>
             <remarks>
             M-Documentation:
             SPECSUB performs speech enhancement using spectral subtraction [SS,ZO]=(S,FSZ,P)
             Usage: (1) y=specsub(x,fs);      enhance the speech using default parameters
             Inputs:
             si      input speech signal
             fsz     sample frequency in Hz
             Alternatively, the input state from a previous call (see below)
             pp      algorithm parameters [optional]
             Outputs:
             ss        output enhanced speech
             gg(t,f,i) selected time-frequency values (see pp.tf below)
             tt        centre of frames (in seconds)
             ff        centre of frequency bins (in Hz)
             zo        output state (or the 2nd argument if gg,tt,ff are omitted)
             The algorithm operation is controlled by a small number of parameters:
             pp.of             overlap factor = (fft length)/(frame increment) [2]
             pp.ti             desired frame increment [0.016 seconds]
             pp.ri             set to 1 to round ti to the nearest power of 2 samples [0]
             pp.g              subtraction domain: 1=magnitude, 2=power [1]
             pp.e              gain exponent [1]
             pp.am             max oversubtraction factor [3]
             pp.b              max noise attenutaion in power domain [0.01]
             pp.al             SNR for oversubtraction=am (set this to Inf for fixed a) [-5
             dB]
             pp.ah             SNR for oversubtraction=1 [20 dB]
             pp.ne             noise estimation: 0=min statistics, 1=MMSE [0]
             pp.bt             threshold for binary gain or -1 for continuous gain [-1]
             pp.mx             input mixture gain [0]
             pp.gh             maximum gain for noise floor [1]
             pp.rf             round output signal to an exact number of frames [0]
             pp.tf             selects time-frequency planes to output in the gg() variable
             ['g']
             'i' = input power spectrum
             'I' = input complex spectrum
             'n' = noise power spectrum
             'g' = gain
             'o' = output power spectrum
             'O' = output complex spectrum
             Following [1], the magnitude-domain gain in each time-frequency bin is given by
             gain=mx+(1-mx)*max((1-(a*N/X)^(g/2))^(e/g),min(gh,(b*N/X)^(e/2)))
             where N and X are the powers of the noise and noisy speech respectively.
             The oversubtraction factor varies linearly between a=am for a frame SNR of al
             down to
             a=1 for a frame SNR of ah. To obtain a fixed value of a for all values of SNR,
             set al=Inf.
             Common exponent combinations are:
             g=1  e=1    Magnitude Domain spectral subtraction
             g=2  e=1    Power Domain spectral subtraction
             g=2  e=2    Wiener filtering
             Many authors use the parameters alpha=a^(g/2), beta=b^(g/2) and gamma2=e/g
             instead of a, b and e
             but this increases interdependence amongst the parameters.
             If bt>=0 then the max(...) expression above is thresholded to become 0 or 1.
             In addition it is possible to specify parameters for the noise estimation
             algorithm
             which implements reference [2] or [3] according to the setting of pp.ne
             Minimum statistics noise estimate [2]: pp.ne=0 
             pp.taca         (11): smoothing time constant for alpha_c [0.0449 seconds]
             pp.tamax        (3): max smoothing time constant [0.392 seconds]
             pp.taminh       (3): min smoothing time constant (upper limit) [0.0133 seconds]
             pp.tpfall       (12): time constant for P to fall [0.064 seconds]
             pp.tbmax        (20): max smoothing time constant [0.0717 seconds]
             pp.qeqmin       (23): minimum value of Qeq [2]
             pp.qeqmax       max value of Qeq per frame [14]
             pp.av           (23)+13 lines: fudge factor for bc calculation  [2.12]
             pp.td           time to take minimum over [1.536 seconds]
             pp.nu           number of subwindows to use [3]
             pp.qith         Q-inverse thresholds to select maximum noise slope [0.03 0.05
             0.06 Inf ]
             pp.nsmdb        corresponding noise slope thresholds in dB/second   [47 31.4 15.7
             4.1]
             MMSE noise estimate [3]: pp.ne=1 
             pp.tax         smoothing time constant for noise power estimate [0.0717
             seconds](8)
             pp.tap         smoothing time constant for smoothed speech prob [0.152
             seconds](23)
             pp.psthr       threshold for smoothed speech probability [0.99] (24)
             pp.pnsaf       noise probability safety value [0.01] (24)
             pp.pspri       prior speech probability [0.5] (18)
             pp.asnr        active SNR in dB [15] (18)
             pp.psini       initial speech probability [0.5] (23)
             pp.tavini      assumed speech absent time at start [0.064 seconds]
             If convenient, you can call specsub in chunks of arbitrary size. Thus the
             following are equivalent:
             (a) y=specsub(s,fs);
             (b) [y1,z]=specsub(s(1:1000),fs);
             [y2,z]=specsub(s(1001:2000),z);
             y3=specsub(s(2001:end),z);
             y=[y1; y2; y3];
             If the number of output arguments is either 2 or 5, the last partial frame of
             samples will
             be retained for overlap adding with the output from the next call to specsub().
             See also ssubmmse() for an alternative gain function
             Refs:
             [1] M. Berouti, R. Schwartz and J. Makhoul
             Enhancement of speech corrupted by acoustic noise
             Proc IEEE ICASSP, 1979, 4, 208-211
             [2] Rainer Martin.
             Noise power spectral density estimation based on optimal smoothing and minimum
             statistics.
             IEEE Trans. Speech and Audio Processing, 9(5):504-512, July 2001.
             [3] Gerkmann, T. &amp; Hendriks, R. C.
             Unbiased MMSE-Based Noise Power Estimation With Low Complexity and Low Tracking
             Delay
             IEEE Trans Audio, Speech, Language Processing, 2012, 20, 1383-1393
             </remarks>
             <param name="si">Input argument #1</param>
             <param name="fsz">Input argument #2</param>
             <returns>An MWArray containing the first output argument.</returns>
            
        </member>
        <member name="M:FilterLib.FilterClass.specsub(MathWorks.MATLAB.NET.Arrays.MWArray,MathWorks.MATLAB.NET.Arrays.MWArray,MathWorks.MATLAB.NET.Arrays.MWArray)">
             <summary>
             Provides a single output, 3-input MWArrayinterface to the specsub MATLAB
             function.
             </summary>
             <remarks>
             M-Documentation:
             SPECSUB performs speech enhancement using spectral subtraction [SS,ZO]=(S,FSZ,P)
             Usage: (1) y=specsub(x,fs);      enhance the speech using default parameters
             Inputs:
             si      input speech signal
             fsz     sample frequency in Hz
             Alternatively, the input state from a previous call (see below)
             pp      algorithm parameters [optional]
             Outputs:
             ss        output enhanced speech
             gg(t,f,i) selected time-frequency values (see pp.tf below)
             tt        centre of frames (in seconds)
             ff        centre of frequency bins (in Hz)
             zo        output state (or the 2nd argument if gg,tt,ff are omitted)
             The algorithm operation is controlled by a small number of parameters:
             pp.of             overlap factor = (fft length)/(frame increment) [2]
             pp.ti             desired frame increment [0.016 seconds]
             pp.ri             set to 1 to round ti to the nearest power of 2 samples [0]
             pp.g              subtraction domain: 1=magnitude, 2=power [1]
             pp.e              gain exponent [1]
             pp.am             max oversubtraction factor [3]
             pp.b              max noise attenutaion in power domain [0.01]
             pp.al             SNR for oversubtraction=am (set this to Inf for fixed a) [-5
             dB]
             pp.ah             SNR for oversubtraction=1 [20 dB]
             pp.ne             noise estimation: 0=min statistics, 1=MMSE [0]
             pp.bt             threshold for binary gain or -1 for continuous gain [-1]
             pp.mx             input mixture gain [0]
             pp.gh             maximum gain for noise floor [1]
             pp.rf             round output signal to an exact number of frames [0]
             pp.tf             selects time-frequency planes to output in the gg() variable
             ['g']
             'i' = input power spectrum
             'I' = input complex spectrum
             'n' = noise power spectrum
             'g' = gain
             'o' = output power spectrum
             'O' = output complex spectrum
             Following [1], the magnitude-domain gain in each time-frequency bin is given by
             gain=mx+(1-mx)*max((1-(a*N/X)^(g/2))^(e/g),min(gh,(b*N/X)^(e/2)))
             where N and X are the powers of the noise and noisy speech respectively.
             The oversubtraction factor varies linearly between a=am for a frame SNR of al
             down to
             a=1 for a frame SNR of ah. To obtain a fixed value of a for all values of SNR,
             set al=Inf.
             Common exponent combinations are:
             g=1  e=1    Magnitude Domain spectral subtraction
             g=2  e=1    Power Domain spectral subtraction
             g=2  e=2    Wiener filtering
             Many authors use the parameters alpha=a^(g/2), beta=b^(g/2) and gamma2=e/g
             instead of a, b and e
             but this increases interdependence amongst the parameters.
             If bt>=0 then the max(...) expression above is thresholded to become 0 or 1.
             In addition it is possible to specify parameters for the noise estimation
             algorithm
             which implements reference [2] or [3] according to the setting of pp.ne
             Minimum statistics noise estimate [2]: pp.ne=0 
             pp.taca         (11): smoothing time constant for alpha_c [0.0449 seconds]
             pp.tamax        (3): max smoothing time constant [0.392 seconds]
             pp.taminh       (3): min smoothing time constant (upper limit) [0.0133 seconds]
             pp.tpfall       (12): time constant for P to fall [0.064 seconds]
             pp.tbmax        (20): max smoothing time constant [0.0717 seconds]
             pp.qeqmin       (23): minimum value of Qeq [2]
             pp.qeqmax       max value of Qeq per frame [14]
             pp.av           (23)+13 lines: fudge factor for bc calculation  [2.12]
             pp.td           time to take minimum over [1.536 seconds]
             pp.nu           number of subwindows to use [3]
             pp.qith         Q-inverse thresholds to select maximum noise slope [0.03 0.05
             0.06 Inf ]
             pp.nsmdb        corresponding noise slope thresholds in dB/second   [47 31.4 15.7
             4.1]
             MMSE noise estimate [3]: pp.ne=1 
             pp.tax         smoothing time constant for noise power estimate [0.0717
             seconds](8)
             pp.tap         smoothing time constant for smoothed speech prob [0.152
             seconds](23)
             pp.psthr       threshold for smoothed speech probability [0.99] (24)
             pp.pnsaf       noise probability safety value [0.01] (24)
             pp.pspri       prior speech probability [0.5] (18)
             pp.asnr        active SNR in dB [15] (18)
             pp.psini       initial speech probability [0.5] (23)
             pp.tavini      assumed speech absent time at start [0.064 seconds]
             If convenient, you can call specsub in chunks of arbitrary size. Thus the
             following are equivalent:
             (a) y=specsub(s,fs);
             (b) [y1,z]=specsub(s(1:1000),fs);
             [y2,z]=specsub(s(1001:2000),z);
             y3=specsub(s(2001:end),z);
             y=[y1; y2; y3];
             If the number of output arguments is either 2 or 5, the last partial frame of
             samples will
             be retained for overlap adding with the output from the next call to specsub().
             See also ssubmmse() for an alternative gain function
             Refs:
             [1] M. Berouti, R. Schwartz and J. Makhoul
             Enhancement of speech corrupted by acoustic noise
             Proc IEEE ICASSP, 1979, 4, 208-211
             [2] Rainer Martin.
             Noise power spectral density estimation based on optimal smoothing and minimum
             statistics.
             IEEE Trans. Speech and Audio Processing, 9(5):504-512, July 2001.
             [3] Gerkmann, T. &amp; Hendriks, R. C.
             Unbiased MMSE-Based Noise Power Estimation With Low Complexity and Low Tracking
             Delay
             IEEE Trans Audio, Speech, Language Processing, 2012, 20, 1383-1393
             </remarks>
             <param name="si">Input argument #1</param>
             <param name="fsz">Input argument #2</param>
             <param name="pp">Input argument #3</param>
             <returns>An MWArray containing the first output argument.</returns>
            
        </member>
        <member name="M:FilterLib.FilterClass.specsub(System.Int32)">
             <summary>
             Provides the standard 0-input MWArray interface to the specsub MATLAB function.
             </summary>
             <remarks>
             M-Documentation:
             SPECSUB performs speech enhancement using spectral subtraction [SS,ZO]=(S,FSZ,P)
             Usage: (1) y=specsub(x,fs);      enhance the speech using default parameters
             Inputs:
             si      input speech signal
             fsz     sample frequency in Hz
             Alternatively, the input state from a previous call (see below)
             pp      algorithm parameters [optional]
             Outputs:
             ss        output enhanced speech
             gg(t,f,i) selected time-frequency values (see pp.tf below)
             tt        centre of frames (in seconds)
             ff        centre of frequency bins (in Hz)
             zo        output state (or the 2nd argument if gg,tt,ff are omitted)
             The algorithm operation is controlled by a small number of parameters:
             pp.of             overlap factor = (fft length)/(frame increment) [2]
             pp.ti             desired frame increment [0.016 seconds]
             pp.ri             set to 1 to round ti to the nearest power of 2 samples [0]
             pp.g              subtraction domain: 1=magnitude, 2=power [1]
             pp.e              gain exponent [1]
             pp.am             max oversubtraction factor [3]
             pp.b              max noise attenutaion in power domain [0.01]
             pp.al             SNR for oversubtraction=am (set this to Inf for fixed a) [-5
             dB]
             pp.ah             SNR for oversubtraction=1 [20 dB]
             pp.ne             noise estimation: 0=min statistics, 1=MMSE [0]
             pp.bt             threshold for binary gain or -1 for continuous gain [-1]
             pp.mx             input mixture gain [0]
             pp.gh             maximum gain for noise floor [1]
             pp.rf             round output signal to an exact number of frames [0]
             pp.tf             selects time-frequency planes to output in the gg() variable
             ['g']
             'i' = input power spectrum
             'I' = input complex spectrum
             'n' = noise power spectrum
             'g' = gain
             'o' = output power spectrum
             'O' = output complex spectrum
             Following [1], the magnitude-domain gain in each time-frequency bin is given by
             gain=mx+(1-mx)*max((1-(a*N/X)^(g/2))^(e/g),min(gh,(b*N/X)^(e/2)))
             where N and X are the powers of the noise and noisy speech respectively.
             The oversubtraction factor varies linearly between a=am for a frame SNR of al
             down to
             a=1 for a frame SNR of ah. To obtain a fixed value of a for all values of SNR,
             set al=Inf.
             Common exponent combinations are:
             g=1  e=1    Magnitude Domain spectral subtraction
             g=2  e=1    Power Domain spectral subtraction
             g=2  e=2    Wiener filtering
             Many authors use the parameters alpha=a^(g/2), beta=b^(g/2) and gamma2=e/g
             instead of a, b and e
             but this increases interdependence amongst the parameters.
             If bt>=0 then the max(...) expression above is thresholded to become 0 or 1.
             In addition it is possible to specify parameters for the noise estimation
             algorithm
             which implements reference [2] or [3] according to the setting of pp.ne
             Minimum statistics noise estimate [2]: pp.ne=0 
             pp.taca         (11): smoothing time constant for alpha_c [0.0449 seconds]
             pp.tamax        (3): max smoothing time constant [0.392 seconds]
             pp.taminh       (3): min smoothing time constant (upper limit) [0.0133 seconds]
             pp.tpfall       (12): time constant for P to fall [0.064 seconds]
             pp.tbmax        (20): max smoothing time constant [0.0717 seconds]
             pp.qeqmin       (23): minimum value of Qeq [2]
             pp.qeqmax       max value of Qeq per frame [14]
             pp.av           (23)+13 lines: fudge factor for bc calculation  [2.12]
             pp.td           time to take minimum over [1.536 seconds]
             pp.nu           number of subwindows to use [3]
             pp.qith         Q-inverse thresholds to select maximum noise slope [0.03 0.05
             0.06 Inf ]
             pp.nsmdb        corresponding noise slope thresholds in dB/second   [47 31.4 15.7
             4.1]
             MMSE noise estimate [3]: pp.ne=1 
             pp.tax         smoothing time constant for noise power estimate [0.0717
             seconds](8)
             pp.tap         smoothing time constant for smoothed speech prob [0.152
             seconds](23)
             pp.psthr       threshold for smoothed speech probability [0.99] (24)
             pp.pnsaf       noise probability safety value [0.01] (24)
             pp.pspri       prior speech probability [0.5] (18)
             pp.asnr        active SNR in dB [15] (18)
             pp.psini       initial speech probability [0.5] (23)
             pp.tavini      assumed speech absent time at start [0.064 seconds]
             If convenient, you can call specsub in chunks of arbitrary size. Thus the
             following are equivalent:
             (a) y=specsub(s,fs);
             (b) [y1,z]=specsub(s(1:1000),fs);
             [y2,z]=specsub(s(1001:2000),z);
             y3=specsub(s(2001:end),z);
             y=[y1; y2; y3];
             If the number of output arguments is either 2 or 5, the last partial frame of
             samples will
             be retained for overlap adding with the output from the next call to specsub().
             See also ssubmmse() for an alternative gain function
             Refs:
             [1] M. Berouti, R. Schwartz and J. Makhoul
             Enhancement of speech corrupted by acoustic noise
             Proc IEEE ICASSP, 1979, 4, 208-211
             [2] Rainer Martin.
             Noise power spectral density estimation based on optimal smoothing and minimum
             statistics.
             IEEE Trans. Speech and Audio Processing, 9(5):504-512, July 2001.
             [3] Gerkmann, T. &amp; Hendriks, R. C.
             Unbiased MMSE-Based Noise Power Estimation With Low Complexity and Low Tracking
             Delay
             IEEE Trans Audio, Speech, Language Processing, 2012, 20, 1383-1393
             </remarks>
             <param name="numArgsOut">The number of output arguments to return.</param>
             <returns>An Array of length "numArgsOut" containing the output
             arguments.</returns>
            
        </member>
        <member name="M:FilterLib.FilterClass.specsub(System.Int32,MathWorks.MATLAB.NET.Arrays.MWArray)">
             <summary>
             Provides the standard 1-input MWArray interface to the specsub MATLAB function.
             </summary>
             <remarks>
             M-Documentation:
             SPECSUB performs speech enhancement using spectral subtraction [SS,ZO]=(S,FSZ,P)
             Usage: (1) y=specsub(x,fs);      enhance the speech using default parameters
             Inputs:
             si      input speech signal
             fsz     sample frequency in Hz
             Alternatively, the input state from a previous call (see below)
             pp      algorithm parameters [optional]
             Outputs:
             ss        output enhanced speech
             gg(t,f,i) selected time-frequency values (see pp.tf below)
             tt        centre of frames (in seconds)
             ff        centre of frequency bins (in Hz)
             zo        output state (or the 2nd argument if gg,tt,ff are omitted)
             The algorithm operation is controlled by a small number of parameters:
             pp.of             overlap factor = (fft length)/(frame increment) [2]
             pp.ti             desired frame increment [0.016 seconds]
             pp.ri             set to 1 to round ti to the nearest power of 2 samples [0]
             pp.g              subtraction domain: 1=magnitude, 2=power [1]
             pp.e              gain exponent [1]
             pp.am             max oversubtraction factor [3]
             pp.b              max noise attenutaion in power domain [0.01]
             pp.al             SNR for oversubtraction=am (set this to Inf for fixed a) [-5
             dB]
             pp.ah             SNR for oversubtraction=1 [20 dB]
             pp.ne             noise estimation: 0=min statistics, 1=MMSE [0]
             pp.bt             threshold for binary gain or -1 for continuous gain [-1]
             pp.mx             input mixture gain [0]
             pp.gh             maximum gain for noise floor [1]
             pp.rf             round output signal to an exact number of frames [0]
             pp.tf             selects time-frequency planes to output in the gg() variable
             ['g']
             'i' = input power spectrum
             'I' = input complex spectrum
             'n' = noise power spectrum
             'g' = gain
             'o' = output power spectrum
             'O' = output complex spectrum
             Following [1], the magnitude-domain gain in each time-frequency bin is given by
             gain=mx+(1-mx)*max((1-(a*N/X)^(g/2))^(e/g),min(gh,(b*N/X)^(e/2)))
             where N and X are the powers of the noise and noisy speech respectively.
             The oversubtraction factor varies linearly between a=am for a frame SNR of al
             down to
             a=1 for a frame SNR of ah. To obtain a fixed value of a for all values of SNR,
             set al=Inf.
             Common exponent combinations are:
             g=1  e=1    Magnitude Domain spectral subtraction
             g=2  e=1    Power Domain spectral subtraction
             g=2  e=2    Wiener filtering
             Many authors use the parameters alpha=a^(g/2), beta=b^(g/2) and gamma2=e/g
             instead of a, b and e
             but this increases interdependence amongst the parameters.
             If bt>=0 then the max(...) expression above is thresholded to become 0 or 1.
             In addition it is possible to specify parameters for the noise estimation
             algorithm
             which implements reference [2] or [3] according to the setting of pp.ne
             Minimum statistics noise estimate [2]: pp.ne=0 
             pp.taca         (11): smoothing time constant for alpha_c [0.0449 seconds]
             pp.tamax        (3): max smoothing time constant [0.392 seconds]
             pp.taminh       (3): min smoothing time constant (upper limit) [0.0133 seconds]
             pp.tpfall       (12): time constant for P to fall [0.064 seconds]
             pp.tbmax        (20): max smoothing time constant [0.0717 seconds]
             pp.qeqmin       (23): minimum value of Qeq [2]
             pp.qeqmax       max value of Qeq per frame [14]
             pp.av           (23)+13 lines: fudge factor for bc calculation  [2.12]
             pp.td           time to take minimum over [1.536 seconds]
             pp.nu           number of subwindows to use [3]
             pp.qith         Q-inverse thresholds to select maximum noise slope [0.03 0.05
             0.06 Inf ]
             pp.nsmdb        corresponding noise slope thresholds in dB/second   [47 31.4 15.7
             4.1]
             MMSE noise estimate [3]: pp.ne=1 
             pp.tax         smoothing time constant for noise power estimate [0.0717
             seconds](8)
             pp.tap         smoothing time constant for smoothed speech prob [0.152
             seconds](23)
             pp.psthr       threshold for smoothed speech probability [0.99] (24)
             pp.pnsaf       noise probability safety value [0.01] (24)
             pp.pspri       prior speech probability [0.5] (18)
             pp.asnr        active SNR in dB [15] (18)
             pp.psini       initial speech probability [0.5] (23)
             pp.tavini      assumed speech absent time at start [0.064 seconds]
             If convenient, you can call specsub in chunks of arbitrary size. Thus the
             following are equivalent:
             (a) y=specsub(s,fs);
             (b) [y1,z]=specsub(s(1:1000),fs);
             [y2,z]=specsub(s(1001:2000),z);
             y3=specsub(s(2001:end),z);
             y=[y1; y2; y3];
             If the number of output arguments is either 2 or 5, the last partial frame of
             samples will
             be retained for overlap adding with the output from the next call to specsub().
             See also ssubmmse() for an alternative gain function
             Refs:
             [1] M. Berouti, R. Schwartz and J. Makhoul
             Enhancement of speech corrupted by acoustic noise
             Proc IEEE ICASSP, 1979, 4, 208-211
             [2] Rainer Martin.
             Noise power spectral density estimation based on optimal smoothing and minimum
             statistics.
             IEEE Trans. Speech and Audio Processing, 9(5):504-512, July 2001.
             [3] Gerkmann, T. &amp; Hendriks, R. C.
             Unbiased MMSE-Based Noise Power Estimation With Low Complexity and Low Tracking
             Delay
             IEEE Trans Audio, Speech, Language Processing, 2012, 20, 1383-1393
             </remarks>
             <param name="numArgsOut">The number of output arguments to return.</param>
             <param name="si">Input argument #1</param>
             <returns>An Array of length "numArgsOut" containing the output
             arguments.</returns>
            
        </member>
        <member name="M:FilterLib.FilterClass.specsub(System.Int32,MathWorks.MATLAB.NET.Arrays.MWArray,MathWorks.MATLAB.NET.Arrays.MWArray)">
             <summary>
             Provides the standard 2-input MWArray interface to the specsub MATLAB function.
             </summary>
             <remarks>
             M-Documentation:
             SPECSUB performs speech enhancement using spectral subtraction [SS,ZO]=(S,FSZ,P)
             Usage: (1) y=specsub(x,fs);      enhance the speech using default parameters
             Inputs:
             si      input speech signal
             fsz     sample frequency in Hz
             Alternatively, the input state from a previous call (see below)
             pp      algorithm parameters [optional]
             Outputs:
             ss        output enhanced speech
             gg(t,f,i) selected time-frequency values (see pp.tf below)
             tt        centre of frames (in seconds)
             ff        centre of frequency bins (in Hz)
             zo        output state (or the 2nd argument if gg,tt,ff are omitted)
             The algorithm operation is controlled by a small number of parameters:
             pp.of             overlap factor = (fft length)/(frame increment) [2]
             pp.ti             desired frame increment [0.016 seconds]
             pp.ri             set to 1 to round ti to the nearest power of 2 samples [0]
             pp.g              subtraction domain: 1=magnitude, 2=power [1]
             pp.e              gain exponent [1]
             pp.am             max oversubtraction factor [3]
             pp.b              max noise attenutaion in power domain [0.01]
             pp.al             SNR for oversubtraction=am (set this to Inf for fixed a) [-5
             dB]
             pp.ah             SNR for oversubtraction=1 [20 dB]
             pp.ne             noise estimation: 0=min statistics, 1=MMSE [0]
             pp.bt             threshold for binary gain or -1 for continuous gain [-1]
             pp.mx             input mixture gain [0]
             pp.gh             maximum gain for noise floor [1]
             pp.rf             round output signal to an exact number of frames [0]
             pp.tf             selects time-frequency planes to output in the gg() variable
             ['g']
             'i' = input power spectrum
             'I' = input complex spectrum
             'n' = noise power spectrum
             'g' = gain
             'o' = output power spectrum
             'O' = output complex spectrum
             Following [1], the magnitude-domain gain in each time-frequency bin is given by
             gain=mx+(1-mx)*max((1-(a*N/X)^(g/2))^(e/g),min(gh,(b*N/X)^(e/2)))
             where N and X are the powers of the noise and noisy speech respectively.
             The oversubtraction factor varies linearly between a=am for a frame SNR of al
             down to
             a=1 for a frame SNR of ah. To obtain a fixed value of a for all values of SNR,
             set al=Inf.
             Common exponent combinations are:
             g=1  e=1    Magnitude Domain spectral subtraction
             g=2  e=1    Power Domain spectral subtraction
             g=2  e=2    Wiener filtering
             Many authors use the parameters alpha=a^(g/2), beta=b^(g/2) and gamma2=e/g
             instead of a, b and e
             but this increases interdependence amongst the parameters.
             If bt>=0 then the max(...) expression above is thresholded to become 0 or 1.
             In addition it is possible to specify parameters for the noise estimation
             algorithm
             which implements reference [2] or [3] according to the setting of pp.ne
             Minimum statistics noise estimate [2]: pp.ne=0 
             pp.taca         (11): smoothing time constant for alpha_c [0.0449 seconds]
             pp.tamax        (3): max smoothing time constant [0.392 seconds]
             pp.taminh       (3): min smoothing time constant (upper limit) [0.0133 seconds]
             pp.tpfall       (12): time constant for P to fall [0.064 seconds]
             pp.tbmax        (20): max smoothing time constant [0.0717 seconds]
             pp.qeqmin       (23): minimum value of Qeq [2]
             pp.qeqmax       max value of Qeq per frame [14]
             pp.av           (23)+13 lines: fudge factor for bc calculation  [2.12]
             pp.td           time to take minimum over [1.536 seconds]
             pp.nu           number of subwindows to use [3]
             pp.qith         Q-inverse thresholds to select maximum noise slope [0.03 0.05
             0.06 Inf ]
             pp.nsmdb        corresponding noise slope thresholds in dB/second   [47 31.4 15.7
             4.1]
             MMSE noise estimate [3]: pp.ne=1 
             pp.tax         smoothing time constant for noise power estimate [0.0717
             seconds](8)
             pp.tap         smoothing time constant for smoothed speech prob [0.152
             seconds](23)
             pp.psthr       threshold for smoothed speech probability [0.99] (24)
             pp.pnsaf       noise probability safety value [0.01] (24)
             pp.pspri       prior speech probability [0.5] (18)
             pp.asnr        active SNR in dB [15] (18)
             pp.psini       initial speech probability [0.5] (23)
             pp.tavini      assumed speech absent time at start [0.064 seconds]
             If convenient, you can call specsub in chunks of arbitrary size. Thus the
             following are equivalent:
             (a) y=specsub(s,fs);
             (b) [y1,z]=specsub(s(1:1000),fs);
             [y2,z]=specsub(s(1001:2000),z);
             y3=specsub(s(2001:end),z);
             y=[y1; y2; y3];
             If the number of output arguments is either 2 or 5, the last partial frame of
             samples will
             be retained for overlap adding with the output from the next call to specsub().
             See also ssubmmse() for an alternative gain function
             Refs:
             [1] M. Berouti, R. Schwartz and J. Makhoul
             Enhancement of speech corrupted by acoustic noise
             Proc IEEE ICASSP, 1979, 4, 208-211
             [2] Rainer Martin.
             Noise power spectral density estimation based on optimal smoothing and minimum
             statistics.
             IEEE Trans. Speech and Audio Processing, 9(5):504-512, July 2001.
             [3] Gerkmann, T. &amp; Hendriks, R. C.
             Unbiased MMSE-Based Noise Power Estimation With Low Complexity and Low Tracking
             Delay
             IEEE Trans Audio, Speech, Language Processing, 2012, 20, 1383-1393
             </remarks>
             <param name="numArgsOut">The number of output arguments to return.</param>
             <param name="si">Input argument #1</param>
             <param name="fsz">Input argument #2</param>
             <returns>An Array of length "numArgsOut" containing the output
             arguments.</returns>
            
        </member>
        <member name="M:FilterLib.FilterClass.specsub(System.Int32,MathWorks.MATLAB.NET.Arrays.MWArray,MathWorks.MATLAB.NET.Arrays.MWArray,MathWorks.MATLAB.NET.Arrays.MWArray)">
             <summary>
             Provides the standard 3-input MWArray interface to the specsub MATLAB function.
             </summary>
             <remarks>
             M-Documentation:
             SPECSUB performs speech enhancement using spectral subtraction [SS,ZO]=(S,FSZ,P)
             Usage: (1) y=specsub(x,fs);      enhance the speech using default parameters
             Inputs:
             si      input speech signal
             fsz     sample frequency in Hz
             Alternatively, the input state from a previous call (see below)
             pp      algorithm parameters [optional]
             Outputs:
             ss        output enhanced speech
             gg(t,f,i) selected time-frequency values (see pp.tf below)
             tt        centre of frames (in seconds)
             ff        centre of frequency bins (in Hz)
             zo        output state (or the 2nd argument if gg,tt,ff are omitted)
             The algorithm operation is controlled by a small number of parameters:
             pp.of             overlap factor = (fft length)/(frame increment) [2]
             pp.ti             desired frame increment [0.016 seconds]
             pp.ri             set to 1 to round ti to the nearest power of 2 samples [0]
             pp.g              subtraction domain: 1=magnitude, 2=power [1]
             pp.e              gain exponent [1]
             pp.am             max oversubtraction factor [3]
             pp.b              max noise attenutaion in power domain [0.01]
             pp.al             SNR for oversubtraction=am (set this to Inf for fixed a) [-5
             dB]
             pp.ah             SNR for oversubtraction=1 [20 dB]
             pp.ne             noise estimation: 0=min statistics, 1=MMSE [0]
             pp.bt             threshold for binary gain or -1 for continuous gain [-1]
             pp.mx             input mixture gain [0]
             pp.gh             maximum gain for noise floor [1]
             pp.rf             round output signal to an exact number of frames [0]
             pp.tf             selects time-frequency planes to output in the gg() variable
             ['g']
             'i' = input power spectrum
             'I' = input complex spectrum
             'n' = noise power spectrum
             'g' = gain
             'o' = output power spectrum
             'O' = output complex spectrum
             Following [1], the magnitude-domain gain in each time-frequency bin is given by
             gain=mx+(1-mx)*max((1-(a*N/X)^(g/2))^(e/g),min(gh,(b*N/X)^(e/2)))
             where N and X are the powers of the noise and noisy speech respectively.
             The oversubtraction factor varies linearly between a=am for a frame SNR of al
             down to
             a=1 for a frame SNR of ah. To obtain a fixed value of a for all values of SNR,
             set al=Inf.
             Common exponent combinations are:
             g=1  e=1    Magnitude Domain spectral subtraction
             g=2  e=1    Power Domain spectral subtraction
             g=2  e=2    Wiener filtering
             Many authors use the parameters alpha=a^(g/2), beta=b^(g/2) and gamma2=e/g
             instead of a, b and e
             but this increases interdependence amongst the parameters.
             If bt>=0 then the max(...) expression above is thresholded to become 0 or 1.
             In addition it is possible to specify parameters for the noise estimation
             algorithm
             which implements reference [2] or [3] according to the setting of pp.ne
             Minimum statistics noise estimate [2]: pp.ne=0 
             pp.taca         (11): smoothing time constant for alpha_c [0.0449 seconds]
             pp.tamax        (3): max smoothing time constant [0.392 seconds]
             pp.taminh       (3): min smoothing time constant (upper limit) [0.0133 seconds]
             pp.tpfall       (12): time constant for P to fall [0.064 seconds]
             pp.tbmax        (20): max smoothing time constant [0.0717 seconds]
             pp.qeqmin       (23): minimum value of Qeq [2]
             pp.qeqmax       max value of Qeq per frame [14]
             pp.av           (23)+13 lines: fudge factor for bc calculation  [2.12]
             pp.td           time to take minimum over [1.536 seconds]
             pp.nu           number of subwindows to use [3]
             pp.qith         Q-inverse thresholds to select maximum noise slope [0.03 0.05
             0.06 Inf ]
             pp.nsmdb        corresponding noise slope thresholds in dB/second   [47 31.4 15.7
             4.1]
             MMSE noise estimate [3]: pp.ne=1 
             pp.tax         smoothing time constant for noise power estimate [0.0717
             seconds](8)
             pp.tap         smoothing time constant for smoothed speech prob [0.152
             seconds](23)
             pp.psthr       threshold for smoothed speech probability [0.99] (24)
             pp.pnsaf       noise probability safety value [0.01] (24)
             pp.pspri       prior speech probability [0.5] (18)
             pp.asnr        active SNR in dB [15] (18)
             pp.psini       initial speech probability [0.5] (23)
             pp.tavini      assumed speech absent time at start [0.064 seconds]
             If convenient, you can call specsub in chunks of arbitrary size. Thus the
             following are equivalent:
             (a) y=specsub(s,fs);
             (b) [y1,z]=specsub(s(1:1000),fs);
             [y2,z]=specsub(s(1001:2000),z);
             y3=specsub(s(2001:end),z);
             y=[y1; y2; y3];
             If the number of output arguments is either 2 or 5, the last partial frame of
             samples will
             be retained for overlap adding with the output from the next call to specsub().
             See also ssubmmse() for an alternative gain function
             Refs:
             [1] M. Berouti, R. Schwartz and J. Makhoul
             Enhancement of speech corrupted by acoustic noise
             Proc IEEE ICASSP, 1979, 4, 208-211
             [2] Rainer Martin.
             Noise power spectral density estimation based on optimal smoothing and minimum
             statistics.
             IEEE Trans. Speech and Audio Processing, 9(5):504-512, July 2001.
             [3] Gerkmann, T. &amp; Hendriks, R. C.
             Unbiased MMSE-Based Noise Power Estimation With Low Complexity and Low Tracking
             Delay
             IEEE Trans Audio, Speech, Language Processing, 2012, 20, 1383-1393
             </remarks>
             <param name="numArgsOut">The number of output arguments to return.</param>
             <param name="si">Input argument #1</param>
             <param name="fsz">Input argument #2</param>
             <param name="pp">Input argument #3</param>
             <returns>An Array of length "numArgsOut" containing the output
             arguments.</returns>
            
        </member>
        <member name="M:FilterLib.FilterClass.specsub(System.Int32,MathWorks.MATLAB.NET.Arrays.MWArray[]@,MathWorks.MATLAB.NET.Arrays.MWArray[])">
             <summary>
             Provides an interface for the specsub function in which the input and output
             arguments are specified as an array of MWArrays.
             </summary>
             <remarks>
             This method will allocate and return by reference the output argument
             array.<newpara></newpara>
             M-Documentation:
             SPECSUB performs speech enhancement using spectral subtraction [SS,ZO]=(S,FSZ,P)
             Usage: (1) y=specsub(x,fs);      enhance the speech using default parameters
             Inputs:
             si      input speech signal
             fsz     sample frequency in Hz
             Alternatively, the input state from a previous call (see below)
             pp      algorithm parameters [optional]
             Outputs:
             ss        output enhanced speech
             gg(t,f,i) selected time-frequency values (see pp.tf below)
             tt        centre of frames (in seconds)
             ff        centre of frequency bins (in Hz)
             zo        output state (or the 2nd argument if gg,tt,ff are omitted)
             The algorithm operation is controlled by a small number of parameters:
             pp.of             overlap factor = (fft length)/(frame increment) [2]
             pp.ti             desired frame increment [0.016 seconds]
             pp.ri             set to 1 to round ti to the nearest power of 2 samples [0]
             pp.g              subtraction domain: 1=magnitude, 2=power [1]
             pp.e              gain exponent [1]
             pp.am             max oversubtraction factor [3]
             pp.b              max noise attenutaion in power domain [0.01]
             pp.al             SNR for oversubtraction=am (set this to Inf for fixed a) [-5
             dB]
             pp.ah             SNR for oversubtraction=1 [20 dB]
             pp.ne             noise estimation: 0=min statistics, 1=MMSE [0]
             pp.bt             threshold for binary gain or -1 for continuous gain [-1]
             pp.mx             input mixture gain [0]
             pp.gh             maximum gain for noise floor [1]
             pp.rf             round output signal to an exact number of frames [0]
             pp.tf             selects time-frequency planes to output in the gg() variable
             ['g']
             'i' = input power spectrum
             'I' = input complex spectrum
             'n' = noise power spectrum
             'g' = gain
             'o' = output power spectrum
             'O' = output complex spectrum
             Following [1], the magnitude-domain gain in each time-frequency bin is given by
             gain=mx+(1-mx)*max((1-(a*N/X)^(g/2))^(e/g),min(gh,(b*N/X)^(e/2)))
             where N and X are the powers of the noise and noisy speech respectively.
             The oversubtraction factor varies linearly between a=am for a frame SNR of al
             down to
             a=1 for a frame SNR of ah. To obtain a fixed value of a for all values of SNR,
             set al=Inf.
             Common exponent combinations are:
             g=1  e=1    Magnitude Domain spectral subtraction
             g=2  e=1    Power Domain spectral subtraction
             g=2  e=2    Wiener filtering
             Many authors use the parameters alpha=a^(g/2), beta=b^(g/2) and gamma2=e/g
             instead of a, b and e
             but this increases interdependence amongst the parameters.
             If bt>=0 then the max(...) expression above is thresholded to become 0 or 1.
             In addition it is possible to specify parameters for the noise estimation
             algorithm
             which implements reference [2] or [3] according to the setting of pp.ne
             Minimum statistics noise estimate [2]: pp.ne=0 
             pp.taca         (11): smoothing time constant for alpha_c [0.0449 seconds]
             pp.tamax        (3): max smoothing time constant [0.392 seconds]
             pp.taminh       (3): min smoothing time constant (upper limit) [0.0133 seconds]
             pp.tpfall       (12): time constant for P to fall [0.064 seconds]
             pp.tbmax        (20): max smoothing time constant [0.0717 seconds]
             pp.qeqmin       (23): minimum value of Qeq [2]
             pp.qeqmax       max value of Qeq per frame [14]
             pp.av           (23)+13 lines: fudge factor for bc calculation  [2.12]
             pp.td           time to take minimum over [1.536 seconds]
             pp.nu           number of subwindows to use [3]
             pp.qith         Q-inverse thresholds to select maximum noise slope [0.03 0.05
             0.06 Inf ]
             pp.nsmdb        corresponding noise slope thresholds in dB/second   [47 31.4 15.7
             4.1]
             MMSE noise estimate [3]: pp.ne=1 
             pp.tax         smoothing time constant for noise power estimate [0.0717
             seconds](8)
             pp.tap         smoothing time constant for smoothed speech prob [0.152
             seconds](23)
             pp.psthr       threshold for smoothed speech probability [0.99] (24)
             pp.pnsaf       noise probability safety value [0.01] (24)
             pp.pspri       prior speech probability [0.5] (18)
             pp.asnr        active SNR in dB [15] (18)
             pp.psini       initial speech probability [0.5] (23)
             pp.tavini      assumed speech absent time at start [0.064 seconds]
             If convenient, you can call specsub in chunks of arbitrary size. Thus the
             following are equivalent:
             (a) y=specsub(s,fs);
             (b) [y1,z]=specsub(s(1:1000),fs);
             [y2,z]=specsub(s(1001:2000),z);
             y3=specsub(s(2001:end),z);
             y=[y1; y2; y3];
             If the number of output arguments is either 2 or 5, the last partial frame of
             samples will
             be retained for overlap adding with the output from the next call to specsub().
             See also ssubmmse() for an alternative gain function
             Refs:
             [1] M. Berouti, R. Schwartz and J. Makhoul
             Enhancement of speech corrupted by acoustic noise
             Proc IEEE ICASSP, 1979, 4, 208-211
             [2] Rainer Martin.
             Noise power spectral density estimation based on optimal smoothing and minimum
             statistics.
             IEEE Trans. Speech and Audio Processing, 9(5):504-512, July 2001.
             [3] Gerkmann, T. &amp; Hendriks, R. C.
             Unbiased MMSE-Based Noise Power Estimation With Low Complexity and Low Tracking
             Delay
             IEEE Trans Audio, Speech, Language Processing, 2012, 20, 1383-1393
             </remarks>
             <param name="numArgsOut">The number of output arguments to return</param>
             <param name= "argsOut">Array of MWArray output arguments</param>
             <param name= "argsIn">Array of MWArray input arguments</param>
            
        </member>
        <member name="M:FilterLib.FilterClass.specsubm">
             <summary>
             Provides a single output, 0-input MWArrayinterface to the specsubm MATLAB
             function.
             </summary>
             <remarks>
             M-Documentation:
             SPECSUBM obsolete speech enhancement algorithm - use specsub instead
             implementation of spectral subtraction algorithm by R Martin (rather slow)
             algorithm parameters: t* in seconds, f* in Hz, k* dimensionless
             1: tg = smoothing time constant for signal power estimate (0.04):
             high=reverberant, low=musical
             2: ta = smoothing time constant for signal power estimate
             used in noise estimation (0.1)
             3: tw = fft window length (will be rounded up to 2^nw samples)
             4: tm = length of minimum filter (1.5): high=slow response to noise increase,
             low=distortion
             5: to = time constant for oversubtraction factor (0.08)
             6: fo = oversubtraction corner frequency (800): high=distortion, low=musical
             7: km = number of minimisation buffers to use (4): high=waste memory, low=noise
             modulation
             8: ks = oversampling constant (4)
             9: kn = noise estimate compensation (1.5)
             10:kf = subtraction floor (0.02): high=noisy, low=musical
             11:ko = oversubtraction scale factor (4): high=distortion, low=musical
             Refs:
             (a) R. Martin. Spectral subtraction based on minimum statistics. In Proc EUSIPCO,
             pages 1182-1185, Edinburgh, Sept 1994.
             (b) R. Martin. Noise power spectral density estimation based on optimal smoothing
             and minimum statistics.
             IEEE Trans. Speech and Audio Processing, 9(5):504-512, July 2001.
             </remarks>
             <returns>An MWArray containing the first output argument.</returns>
            
        </member>
        <member name="M:FilterLib.FilterClass.specsubm(MathWorks.MATLAB.NET.Arrays.MWArray)">
             <summary>
             Provides a single output, 1-input MWArrayinterface to the specsubm MATLAB
             function.
             </summary>
             <remarks>
             M-Documentation:
             SPECSUBM obsolete speech enhancement algorithm - use specsub instead
             implementation of spectral subtraction algorithm by R Martin (rather slow)
             algorithm parameters: t* in seconds, f* in Hz, k* dimensionless
             1: tg = smoothing time constant for signal power estimate (0.04):
             high=reverberant, low=musical
             2: ta = smoothing time constant for signal power estimate
             used in noise estimation (0.1)
             3: tw = fft window length (will be rounded up to 2^nw samples)
             4: tm = length of minimum filter (1.5): high=slow response to noise increase,
             low=distortion
             5: to = time constant for oversubtraction factor (0.08)
             6: fo = oversubtraction corner frequency (800): high=distortion, low=musical
             7: km = number of minimisation buffers to use (4): high=waste memory, low=noise
             modulation
             8: ks = oversampling constant (4)
             9: kn = noise estimate compensation (1.5)
             10:kf = subtraction floor (0.02): high=noisy, low=musical
             11:ko = oversubtraction scale factor (4): high=distortion, low=musical
             Refs:
             (a) R. Martin. Spectral subtraction based on minimum statistics. In Proc EUSIPCO,
             pages 1182-1185, Edinburgh, Sept 1994.
             (b) R. Martin. Noise power spectral density estimation based on optimal smoothing
             and minimum statistics.
             IEEE Trans. Speech and Audio Processing, 9(5):504-512, July 2001.
             </remarks>
             <param name="s">Input argument #1</param>
             <returns>An MWArray containing the first output argument.</returns>
            
        </member>
        <member name="M:FilterLib.FilterClass.specsubm(MathWorks.MATLAB.NET.Arrays.MWArray,MathWorks.MATLAB.NET.Arrays.MWArray)">
             <summary>
             Provides a single output, 2-input MWArrayinterface to the specsubm MATLAB
             function.
             </summary>
             <remarks>
             M-Documentation:
             SPECSUBM obsolete speech enhancement algorithm - use specsub instead
             implementation of spectral subtraction algorithm by R Martin (rather slow)
             algorithm parameters: t* in seconds, f* in Hz, k* dimensionless
             1: tg = smoothing time constant for signal power estimate (0.04):
             high=reverberant, low=musical
             2: ta = smoothing time constant for signal power estimate
             used in noise estimation (0.1)
             3: tw = fft window length (will be rounded up to 2^nw samples)
             4: tm = length of minimum filter (1.5): high=slow response to noise increase,
             low=distortion
             5: to = time constant for oversubtraction factor (0.08)
             6: fo = oversubtraction corner frequency (800): high=distortion, low=musical
             7: km = number of minimisation buffers to use (4): high=waste memory, low=noise
             modulation
             8: ks = oversampling constant (4)
             9: kn = noise estimate compensation (1.5)
             10:kf = subtraction floor (0.02): high=noisy, low=musical
             11:ko = oversubtraction scale factor (4): high=distortion, low=musical
             Refs:
             (a) R. Martin. Spectral subtraction based on minimum statistics. In Proc EUSIPCO,
             pages 1182-1185, Edinburgh, Sept 1994.
             (b) R. Martin. Noise power spectral density estimation based on optimal smoothing
             and minimum statistics.
             IEEE Trans. Speech and Audio Processing, 9(5):504-512, July 2001.
             </remarks>
             <param name="s">Input argument #1</param>
             <param name="fs">Input argument #2</param>
             <returns>An MWArray containing the first output argument.</returns>
            
        </member>
        <member name="M:FilterLib.FilterClass.specsubm(MathWorks.MATLAB.NET.Arrays.MWArray,MathWorks.MATLAB.NET.Arrays.MWArray,MathWorks.MATLAB.NET.Arrays.MWArray)">
             <summary>
             Provides a single output, 3-input MWArrayinterface to the specsubm MATLAB
             function.
             </summary>
             <remarks>
             M-Documentation:
             SPECSUBM obsolete speech enhancement algorithm - use specsub instead
             implementation of spectral subtraction algorithm by R Martin (rather slow)
             algorithm parameters: t* in seconds, f* in Hz, k* dimensionless
             1: tg = smoothing time constant for signal power estimate (0.04):
             high=reverberant, low=musical
             2: ta = smoothing time constant for signal power estimate
             used in noise estimation (0.1)
             3: tw = fft window length (will be rounded up to 2^nw samples)
             4: tm = length of minimum filter (1.5): high=slow response to noise increase,
             low=distortion
             5: to = time constant for oversubtraction factor (0.08)
             6: fo = oversubtraction corner frequency (800): high=distortion, low=musical
             7: km = number of minimisation buffers to use (4): high=waste memory, low=noise
             modulation
             8: ks = oversampling constant (4)
             9: kn = noise estimate compensation (1.5)
             10:kf = subtraction floor (0.02): high=noisy, low=musical
             11:ko = oversubtraction scale factor (4): high=distortion, low=musical
             Refs:
             (a) R. Martin. Spectral subtraction based on minimum statistics. In Proc EUSIPCO,
             pages 1182-1185, Edinburgh, Sept 1994.
             (b) R. Martin. Noise power spectral density estimation based on optimal smoothing
             and minimum statistics.
             IEEE Trans. Speech and Audio Processing, 9(5):504-512, July 2001.
             </remarks>
             <param name="s">Input argument #1</param>
             <param name="fs">Input argument #2</param>
             <param name="p">Input argument #3</param>
             <returns>An MWArray containing the first output argument.</returns>
            
        </member>
        <member name="M:FilterLib.FilterClass.specsubm(System.Int32)">
             <summary>
             Provides the standard 0-input MWArray interface to the specsubm MATLAB function.
             </summary>
             <remarks>
             M-Documentation:
             SPECSUBM obsolete speech enhancement algorithm - use specsub instead
             implementation of spectral subtraction algorithm by R Martin (rather slow)
             algorithm parameters: t* in seconds, f* in Hz, k* dimensionless
             1: tg = smoothing time constant for signal power estimate (0.04):
             high=reverberant, low=musical
             2: ta = smoothing time constant for signal power estimate
             used in noise estimation (0.1)
             3: tw = fft window length (will be rounded up to 2^nw samples)
             4: tm = length of minimum filter (1.5): high=slow response to noise increase,
             low=distortion
             5: to = time constant for oversubtraction factor (0.08)
             6: fo = oversubtraction corner frequency (800): high=distortion, low=musical
             7: km = number of minimisation buffers to use (4): high=waste memory, low=noise
             modulation
             8: ks = oversampling constant (4)
             9: kn = noise estimate compensation (1.5)
             10:kf = subtraction floor (0.02): high=noisy, low=musical
             11:ko = oversubtraction scale factor (4): high=distortion, low=musical
             Refs:
             (a) R. Martin. Spectral subtraction based on minimum statistics. In Proc EUSIPCO,
             pages 1182-1185, Edinburgh, Sept 1994.
             (b) R. Martin. Noise power spectral density estimation based on optimal smoothing
             and minimum statistics.
             IEEE Trans. Speech and Audio Processing, 9(5):504-512, July 2001.
             </remarks>
             <param name="numArgsOut">The number of output arguments to return.</param>
             <returns>An Array of length "numArgsOut" containing the output
             arguments.</returns>
            
        </member>
        <member name="M:FilterLib.FilterClass.specsubm(System.Int32,MathWorks.MATLAB.NET.Arrays.MWArray)">
             <summary>
             Provides the standard 1-input MWArray interface to the specsubm MATLAB function.
             </summary>
             <remarks>
             M-Documentation:
             SPECSUBM obsolete speech enhancement algorithm - use specsub instead
             implementation of spectral subtraction algorithm by R Martin (rather slow)
             algorithm parameters: t* in seconds, f* in Hz, k* dimensionless
             1: tg = smoothing time constant for signal power estimate (0.04):
             high=reverberant, low=musical
             2: ta = smoothing time constant for signal power estimate
             used in noise estimation (0.1)
             3: tw = fft window length (will be rounded up to 2^nw samples)
             4: tm = length of minimum filter (1.5): high=slow response to noise increase,
             low=distortion
             5: to = time constant for oversubtraction factor (0.08)
             6: fo = oversubtraction corner frequency (800): high=distortion, low=musical
             7: km = number of minimisation buffers to use (4): high=waste memory, low=noise
             modulation
             8: ks = oversampling constant (4)
             9: kn = noise estimate compensation (1.5)
             10:kf = subtraction floor (0.02): high=noisy, low=musical
             11:ko = oversubtraction scale factor (4): high=distortion, low=musical
             Refs:
             (a) R. Martin. Spectral subtraction based on minimum statistics. In Proc EUSIPCO,
             pages 1182-1185, Edinburgh, Sept 1994.
             (b) R. Martin. Noise power spectral density estimation based on optimal smoothing
             and minimum statistics.
             IEEE Trans. Speech and Audio Processing, 9(5):504-512, July 2001.
             </remarks>
             <param name="numArgsOut">The number of output arguments to return.</param>
             <param name="s">Input argument #1</param>
             <returns>An Array of length "numArgsOut" containing the output
             arguments.</returns>
            
        </member>
        <member name="M:FilterLib.FilterClass.specsubm(System.Int32,MathWorks.MATLAB.NET.Arrays.MWArray,MathWorks.MATLAB.NET.Arrays.MWArray)">
             <summary>
             Provides the standard 2-input MWArray interface to the specsubm MATLAB function.
             </summary>
             <remarks>
             M-Documentation:
             SPECSUBM obsolete speech enhancement algorithm - use specsub instead
             implementation of spectral subtraction algorithm by R Martin (rather slow)
             algorithm parameters: t* in seconds, f* in Hz, k* dimensionless
             1: tg = smoothing time constant for signal power estimate (0.04):
             high=reverberant, low=musical
             2: ta = smoothing time constant for signal power estimate
             used in noise estimation (0.1)
             3: tw = fft window length (will be rounded up to 2^nw samples)
             4: tm = length of minimum filter (1.5): high=slow response to noise increase,
             low=distortion
             5: to = time constant for oversubtraction factor (0.08)
             6: fo = oversubtraction corner frequency (800): high=distortion, low=musical
             7: km = number of minimisation buffers to use (4): high=waste memory, low=noise
             modulation
             8: ks = oversampling constant (4)
             9: kn = noise estimate compensation (1.5)
             10:kf = subtraction floor (0.02): high=noisy, low=musical
             11:ko = oversubtraction scale factor (4): high=distortion, low=musical
             Refs:
             (a) R. Martin. Spectral subtraction based on minimum statistics. In Proc EUSIPCO,
             pages 1182-1185, Edinburgh, Sept 1994.
             (b) R. Martin. Noise power spectral density estimation based on optimal smoothing
             and minimum statistics.
             IEEE Trans. Speech and Audio Processing, 9(5):504-512, July 2001.
             </remarks>
             <param name="numArgsOut">The number of output arguments to return.</param>
             <param name="s">Input argument #1</param>
             <param name="fs">Input argument #2</param>
             <returns>An Array of length "numArgsOut" containing the output
             arguments.</returns>
            
        </member>
        <member name="M:FilterLib.FilterClass.specsubm(System.Int32,MathWorks.MATLAB.NET.Arrays.MWArray,MathWorks.MATLAB.NET.Arrays.MWArray,MathWorks.MATLAB.NET.Arrays.MWArray)">
             <summary>
             Provides the standard 3-input MWArray interface to the specsubm MATLAB function.
             </summary>
             <remarks>
             M-Documentation:
             SPECSUBM obsolete speech enhancement algorithm - use specsub instead
             implementation of spectral subtraction algorithm by R Martin (rather slow)
             algorithm parameters: t* in seconds, f* in Hz, k* dimensionless
             1: tg = smoothing time constant for signal power estimate (0.04):
             high=reverberant, low=musical
             2: ta = smoothing time constant for signal power estimate
             used in noise estimation (0.1)
             3: tw = fft window length (will be rounded up to 2^nw samples)
             4: tm = length of minimum filter (1.5): high=slow response to noise increase,
             low=distortion
             5: to = time constant for oversubtraction factor (0.08)
             6: fo = oversubtraction corner frequency (800): high=distortion, low=musical
             7: km = number of minimisation buffers to use (4): high=waste memory, low=noise
             modulation
             8: ks = oversampling constant (4)
             9: kn = noise estimate compensation (1.5)
             10:kf = subtraction floor (0.02): high=noisy, low=musical
             11:ko = oversubtraction scale factor (4): high=distortion, low=musical
             Refs:
             (a) R. Martin. Spectral subtraction based on minimum statistics. In Proc EUSIPCO,
             pages 1182-1185, Edinburgh, Sept 1994.
             (b) R. Martin. Noise power spectral density estimation based on optimal smoothing
             and minimum statistics.
             IEEE Trans. Speech and Audio Processing, 9(5):504-512, July 2001.
             </remarks>
             <param name="numArgsOut">The number of output arguments to return.</param>
             <param name="s">Input argument #1</param>
             <param name="fs">Input argument #2</param>
             <param name="p">Input argument #3</param>
             <returns>An Array of length "numArgsOut" containing the output
             arguments.</returns>
            
        </member>
        <member name="M:FilterLib.FilterClass.specsubm(System.Int32,MathWorks.MATLAB.NET.Arrays.MWArray[]@,MathWorks.MATLAB.NET.Arrays.MWArray[])">
             <summary>
             Provides an interface for the specsubm function in which the input and output
             arguments are specified as an array of MWArrays.
             </summary>
             <remarks>
             This method will allocate and return by reference the output argument
             array.<newpara></newpara>
             M-Documentation:
             SPECSUBM obsolete speech enhancement algorithm - use specsub instead
             implementation of spectral subtraction algorithm by R Martin (rather slow)
             algorithm parameters: t* in seconds, f* in Hz, k* dimensionless
             1: tg = smoothing time constant for signal power estimate (0.04):
             high=reverberant, low=musical
             2: ta = smoothing time constant for signal power estimate
             used in noise estimation (0.1)
             3: tw = fft window length (will be rounded up to 2^nw samples)
             4: tm = length of minimum filter (1.5): high=slow response to noise increase,
             low=distortion
             5: to = time constant for oversubtraction factor (0.08)
             6: fo = oversubtraction corner frequency (800): high=distortion, low=musical
             7: km = number of minimisation buffers to use (4): high=waste memory, low=noise
             modulation
             8: ks = oversampling constant (4)
             9: kn = noise estimate compensation (1.5)
             10:kf = subtraction floor (0.02): high=noisy, low=musical
             11:ko = oversubtraction scale factor (4): high=distortion, low=musical
             Refs:
             (a) R. Martin. Spectral subtraction based on minimum statistics. In Proc EUSIPCO,
             pages 1182-1185, Edinburgh, Sept 1994.
             (b) R. Martin. Noise power spectral density estimation based on optimal smoothing
             and minimum statistics.
             IEEE Trans. Speech and Audio Processing, 9(5):504-512, July 2001.
             </remarks>
             <param name="numArgsOut">The number of output arguments to return</param>
             <param name= "argsOut">Array of MWArray output arguments</param>
             <param name= "argsIn">Array of MWArray input arguments</param>
            
        </member>
        <member name="M:FilterLib.FilterClass.ssubmmse">
             <summary>
             Provides a single output, 0-input MWArrayinterface to the ssubmmse MATLAB
             function.
             </summary>
             <remarks>
             M-Documentation:
             SSUBMMSE performs speech enhancement using mmse estimate of spectral amplitude or
             log amplitude [SS,ZO]=(S,FSZ,P)
             Usage: y=ssubmmse(x,fs);      enhance the speech using default parameters
             Inputs:
             si      input speech signal
             fsz     sample frequency in Hz
             Alternatively, the input state from a previous call (see below)
             pp      algorithm parameters [optional]
             Outputs:
             ss        output enhanced speech
             gg(t,f,i) selected time-frequency values (see pp.tf below)
             tt        centre of frames (in seconds)
             ff        centre of frequency bins (in Hz)
             zo        output state (or the 2nd argument if gg,tt,ff are omitted)
             The algorithm operation is controlled by a small number of parameters:
             pp.of             overlap factor = (fft length)/(frame increment) [2]
             pp.ti             desired frame increment [0.016 seconds]
             pp.ri             set to 1 to round ti to the nearest power of 2 samples [0]
             pp.ta             time const for smoothing SNR estimate [0.396 seconds]
             pp.gx             maximum posterior SNR as a power ratio [1000 = +30dB]
             pp.gn             min posterior SNR as a power ratio when estimating prior SNR [1
             = 0dB]
             pp.gz             min posterior SNR as a power ratio [0.001 = -30dB]
             pp.xn             minimum prior SNR [0]
             pp.xb             bias compensation factor for prior SNR [1]
             pp.lg             MMSE target: 0=amplitude, 1=log amplitude [1]
             pp.ne             noise estimation: 0=min statistics, 1=MMSE [0]
             pp.bt             threshold for binary gain or -1 for continuous gain [-1]
             pp.mx             input mixture gain [0]
             pp.rf             round output signal to an exact number of frames [0]
             pp.tf             selects time-frequency planes to output in the gg() variable
             ['g']
             'i' = input power spectrum
             'I' = input complex spectrum
             'n' = noise power spectrum
             'z' = "posterior" SNR (i.e. (S+N)/N )
             'x' = "prior" SNR (i.e. S/N )
             'g' = gain
             'o' = output power spectrum
             'O' = output complex spectrum
             The applied gain is mx+(1-mx)*optgain where optgain is calculated according to
             [1] or [2].
             If pp.bt>=0 then optgain is first thresholded with pp.bt to produce a binary gain
             0 or 1.
             The default parameters implement the original algorithm in [1,2].
             Several parameters relate to the estimation of xi, the so-called "prior SNR",
             xi=max(a*pp.xb*xu+(1-a)*max(gami-1,pp.gn-1),pp.xn);
             This is estimated as a smoothed version of 1 less than gami, the "posterior SNR"
             which is the noisy speech power divided by the noise power. This is
             clipped to a min of (pp.gn-1), smoothed using a factor "a" which corresponds to a
             time-constant of pp.ta and then clipped to a minimum of pp.xn. The
             previous value is taken to be pp.xb*xu where xu is the ratio of the
             estimated speech amplitude squared to the noise power.
             In addition it is possible to specify parameters for the noise estimation
             algorithm
             which implements reference [3] or [7] according to the setting of pp.ne
             Minimum statistics noise estimate [3]: pp.ne=0 
             pp.taca         (11): smoothing time constant for alpha_c [0.0449 seconds]
             pp.tamax        (3): max smoothing time constant [0.392 seconds]
             pp.taminh       (3): min smoothing time constant (upper limit) [0.0133 seconds]
             pp.tpfall       (12): time constant for P to fall [0.064 seconds]
             pp.tbmax        (20): max smoothing time constant [0.0717 seconds]
             pp.qeqmin       (23): minimum value of Qeq [2]
             pp.qeqmax       max value of Qeq per frame [14]
             pp.av           (23)+13 lines: fudge factor for bc calculation  [2.12]
             pp.td           time to take minimum over [1.536 seconds]
             pp.nu           number of subwindows to use [3]
             pp.qith         Q-inverse thresholds to select maximum noise slope [0.03 0.05
             0.06 Inf ]
             pp.nsmdb        corresponding noise slope thresholds in dB/second   [47 31.4 15.7
             4.1]
             MMSE noise estimate [7]: pp.ne=1 
             pp.tax         smoothing time constant for noise power estimate [0.0717
             seconds](8)
             pp.tap         smoothing time constant for smoothed speech prob [0.152
             seconds](23)
             pp.psthr       threshold for smoothed speech probability [0.99] (24)
             pp.pnsaf       noise probability safety value [0.01] (24)
             pp.pspri       prior speech probability [0.5] (18)
             pp.asnr        active SNR in dB [15] (18)
             pp.psini       initial speech probability [0.5] (23)
             pp.tavini      assumed speech absent time at start [0.064 seconds]
             If convenient, you can call specsub in chunks of arbitrary size. Thus the
             following are equivalent:
             (a) y=ssubmmse(s,fs);
             (b) [y1,z]=ssubmmse(s(1:1000),fs);
             [y2,z]=ssubmmse(s(1001:2000),z);
             y3=ssubmmse(s(2001:end),z);
             y=[y1; y2; y3];
             If the number of output arguments is either 2 or 5, the last partial frame of
             samples will
             be retained for overlap adding with the output from the next call to ssubmmse().
             See also specsub() for an alternative gain function
             Refs:
             [1] Ephraim, Y. &amp; Malah, D.
             Speech enhancement using a minimum-mean square error short-time spectral
             amplitude estimator
             IEEE Trans Acoustics Speech and Signal Processing, 32(6):1109-1121, Dec 1984
             [2] Ephraim, Y. &amp; Malah, D.
             Speech enhancement using a minimum mean-square error log-spectral amplitude
             estimator
             IEEE Trans Acoustics Speech and Signal Processing, 33(2):443-445, Apr 1985
             [3] Rainer Martin.
             Noise power spectral density estimation based on optimal smoothing and minimum
             statistics.
             IEEE Trans. Speech and Audio Processing, 9(5):504-512, July 2001.
             [4] O. Cappe.
             Elimination of the musical noise phenomenon with the ephraim and malah noise
             suppressor.
             IEEE Trans Speech Audio Processing, 2 (2): 345?349, Apr. 1994. doi:
             10.1109/89.279283.
             [5] J. Erkelens, J. Jensen, and R. Heusdens.
             A data-driven approach to optimizing spectral speech enhancement methods for
             various error criteria.
             Speech Communication, 49: 530?541, 2007. doi: 10.1016/j.specom.2006.06.012.
             [6] R. Martin.
             Statistical methods for the enhancement of noisy speech.
             In J. Benesty, S. Makino, and J. Chen, editors,
             Speech Enhancement, chapter 3, pages 43?64. Springer-Verlag, 2005.
             [7] Gerkmann, T. &amp; Hendriks, R. C.
             Unbiased MMSE-Based Noise Power Estimation With Low Complexity and Low Tracking
             Delay
             IEEE Trans Audio, Speech, Language Processing, 2012, 20, 1383-1393
             </remarks>
             <returns>An MWArray containing the first output argument.</returns>
            
        </member>
        <member name="M:FilterLib.FilterClass.ssubmmse(MathWorks.MATLAB.NET.Arrays.MWArray)">
             <summary>
             Provides a single output, 1-input MWArrayinterface to the ssubmmse MATLAB
             function.
             </summary>
             <remarks>
             M-Documentation:
             SSUBMMSE performs speech enhancement using mmse estimate of spectral amplitude or
             log amplitude [SS,ZO]=(S,FSZ,P)
             Usage: y=ssubmmse(x,fs);      enhance the speech using default parameters
             Inputs:
             si      input speech signal
             fsz     sample frequency in Hz
             Alternatively, the input state from a previous call (see below)
             pp      algorithm parameters [optional]
             Outputs:
             ss        output enhanced speech
             gg(t,f,i) selected time-frequency values (see pp.tf below)
             tt        centre of frames (in seconds)
             ff        centre of frequency bins (in Hz)
             zo        output state (or the 2nd argument if gg,tt,ff are omitted)
             The algorithm operation is controlled by a small number of parameters:
             pp.of             overlap factor = (fft length)/(frame increment) [2]
             pp.ti             desired frame increment [0.016 seconds]
             pp.ri             set to 1 to round ti to the nearest power of 2 samples [0]
             pp.ta             time const for smoothing SNR estimate [0.396 seconds]
             pp.gx             maximum posterior SNR as a power ratio [1000 = +30dB]
             pp.gn             min posterior SNR as a power ratio when estimating prior SNR [1
             = 0dB]
             pp.gz             min posterior SNR as a power ratio [0.001 = -30dB]
             pp.xn             minimum prior SNR [0]
             pp.xb             bias compensation factor for prior SNR [1]
             pp.lg             MMSE target: 0=amplitude, 1=log amplitude [1]
             pp.ne             noise estimation: 0=min statistics, 1=MMSE [0]
             pp.bt             threshold for binary gain or -1 for continuous gain [-1]
             pp.mx             input mixture gain [0]
             pp.rf             round output signal to an exact number of frames [0]
             pp.tf             selects time-frequency planes to output in the gg() variable
             ['g']
             'i' = input power spectrum
             'I' = input complex spectrum
             'n' = noise power spectrum
             'z' = "posterior" SNR (i.e. (S+N)/N )
             'x' = "prior" SNR (i.e. S/N )
             'g' = gain
             'o' = output power spectrum
             'O' = output complex spectrum
             The applied gain is mx+(1-mx)*optgain where optgain is calculated according to
             [1] or [2].
             If pp.bt>=0 then optgain is first thresholded with pp.bt to produce a binary gain
             0 or 1.
             The default parameters implement the original algorithm in [1,2].
             Several parameters relate to the estimation of xi, the so-called "prior SNR",
             xi=max(a*pp.xb*xu+(1-a)*max(gami-1,pp.gn-1),pp.xn);
             This is estimated as a smoothed version of 1 less than gami, the "posterior SNR"
             which is the noisy speech power divided by the noise power. This is
             clipped to a min of (pp.gn-1), smoothed using a factor "a" which corresponds to a
             time-constant of pp.ta and then clipped to a minimum of pp.xn. The
             previous value is taken to be pp.xb*xu where xu is the ratio of the
             estimated speech amplitude squared to the noise power.
             In addition it is possible to specify parameters for the noise estimation
             algorithm
             which implements reference [3] or [7] according to the setting of pp.ne
             Minimum statistics noise estimate [3]: pp.ne=0 
             pp.taca         (11): smoothing time constant for alpha_c [0.0449 seconds]
             pp.tamax        (3): max smoothing time constant [0.392 seconds]
             pp.taminh       (3): min smoothing time constant (upper limit) [0.0133 seconds]
             pp.tpfall       (12): time constant for P to fall [0.064 seconds]
             pp.tbmax        (20): max smoothing time constant [0.0717 seconds]
             pp.qeqmin       (23): minimum value of Qeq [2]
             pp.qeqmax       max value of Qeq per frame [14]
             pp.av           (23)+13 lines: fudge factor for bc calculation  [2.12]
             pp.td           time to take minimum over [1.536 seconds]
             pp.nu           number of subwindows to use [3]
             pp.qith         Q-inverse thresholds to select maximum noise slope [0.03 0.05
             0.06 Inf ]
             pp.nsmdb        corresponding noise slope thresholds in dB/second   [47 31.4 15.7
             4.1]
             MMSE noise estimate [7]: pp.ne=1 
             pp.tax         smoothing time constant for noise power estimate [0.0717
             seconds](8)
             pp.tap         smoothing time constant for smoothed speech prob [0.152
             seconds](23)
             pp.psthr       threshold for smoothed speech probability [0.99] (24)
             pp.pnsaf       noise probability safety value [0.01] (24)
             pp.pspri       prior speech probability [0.5] (18)
             pp.asnr        active SNR in dB [15] (18)
             pp.psini       initial speech probability [0.5] (23)
             pp.tavini      assumed speech absent time at start [0.064 seconds]
             If convenient, you can call specsub in chunks of arbitrary size. Thus the
             following are equivalent:
             (a) y=ssubmmse(s,fs);
             (b) [y1,z]=ssubmmse(s(1:1000),fs);
             [y2,z]=ssubmmse(s(1001:2000),z);
             y3=ssubmmse(s(2001:end),z);
             y=[y1; y2; y3];
             If the number of output arguments is either 2 or 5, the last partial frame of
             samples will
             be retained for overlap adding with the output from the next call to ssubmmse().
             See also specsub() for an alternative gain function
             Refs:
             [1] Ephraim, Y. &amp; Malah, D.
             Speech enhancement using a minimum-mean square error short-time spectral
             amplitude estimator
             IEEE Trans Acoustics Speech and Signal Processing, 32(6):1109-1121, Dec 1984
             [2] Ephraim, Y. &amp; Malah, D.
             Speech enhancement using a minimum mean-square error log-spectral amplitude
             estimator
             IEEE Trans Acoustics Speech and Signal Processing, 33(2):443-445, Apr 1985
             [3] Rainer Martin.
             Noise power spectral density estimation based on optimal smoothing and minimum
             statistics.
             IEEE Trans. Speech and Audio Processing, 9(5):504-512, July 2001.
             [4] O. Cappe.
             Elimination of the musical noise phenomenon with the ephraim and malah noise
             suppressor.
             IEEE Trans Speech Audio Processing, 2 (2): 345?349, Apr. 1994. doi:
             10.1109/89.279283.
             [5] J. Erkelens, J. Jensen, and R. Heusdens.
             A data-driven approach to optimizing spectral speech enhancement methods for
             various error criteria.
             Speech Communication, 49: 530?541, 2007. doi: 10.1016/j.specom.2006.06.012.
             [6] R. Martin.
             Statistical methods for the enhancement of noisy speech.
             In J. Benesty, S. Makino, and J. Chen, editors,
             Speech Enhancement, chapter 3, pages 43?64. Springer-Verlag, 2005.
             [7] Gerkmann, T. &amp; Hendriks, R. C.
             Unbiased MMSE-Based Noise Power Estimation With Low Complexity and Low Tracking
             Delay
             IEEE Trans Audio, Speech, Language Processing, 2012, 20, 1383-1393
             </remarks>
             <param name="si">Input argument #1</param>
             <returns>An MWArray containing the first output argument.</returns>
            
        </member>
        <member name="M:FilterLib.FilterClass.ssubmmse(MathWorks.MATLAB.NET.Arrays.MWArray,MathWorks.MATLAB.NET.Arrays.MWArray)">
             <summary>
             Provides a single output, 2-input MWArrayinterface to the ssubmmse MATLAB
             function.
             </summary>
             <remarks>
             M-Documentation:
             SSUBMMSE performs speech enhancement using mmse estimate of spectral amplitude or
             log amplitude [SS,ZO]=(S,FSZ,P)
             Usage: y=ssubmmse(x,fs);      enhance the speech using default parameters
             Inputs:
             si      input speech signal
             fsz     sample frequency in Hz
             Alternatively, the input state from a previous call (see below)
             pp      algorithm parameters [optional]
             Outputs:
             ss        output enhanced speech
             gg(t,f,i) selected time-frequency values (see pp.tf below)
             tt        centre of frames (in seconds)
             ff        centre of frequency bins (in Hz)
             zo        output state (or the 2nd argument if gg,tt,ff are omitted)
             The algorithm operation is controlled by a small number of parameters:
             pp.of             overlap factor = (fft length)/(frame increment) [2]
             pp.ti             desired frame increment [0.016 seconds]
             pp.ri             set to 1 to round ti to the nearest power of 2 samples [0]
             pp.ta             time const for smoothing SNR estimate [0.396 seconds]
             pp.gx             maximum posterior SNR as a power ratio [1000 = +30dB]
             pp.gn             min posterior SNR as a power ratio when estimating prior SNR [1
             = 0dB]
             pp.gz             min posterior SNR as a power ratio [0.001 = -30dB]
             pp.xn             minimum prior SNR [0]
             pp.xb             bias compensation factor for prior SNR [1]
             pp.lg             MMSE target: 0=amplitude, 1=log amplitude [1]
             pp.ne             noise estimation: 0=min statistics, 1=MMSE [0]
             pp.bt             threshold for binary gain or -1 for continuous gain [-1]
             pp.mx             input mixture gain [0]
             pp.rf             round output signal to an exact number of frames [0]
             pp.tf             selects time-frequency planes to output in the gg() variable
             ['g']
             'i' = input power spectrum
             'I' = input complex spectrum
             'n' = noise power spectrum
             'z' = "posterior" SNR (i.e. (S+N)/N )
             'x' = "prior" SNR (i.e. S/N )
             'g' = gain
             'o' = output power spectrum
             'O' = output complex spectrum
             The applied gain is mx+(1-mx)*optgain where optgain is calculated according to
             [1] or [2].
             If pp.bt>=0 then optgain is first thresholded with pp.bt to produce a binary gain
             0 or 1.
             The default parameters implement the original algorithm in [1,2].
             Several parameters relate to the estimation of xi, the so-called "prior SNR",
             xi=max(a*pp.xb*xu+(1-a)*max(gami-1,pp.gn-1),pp.xn);
             This is estimated as a smoothed version of 1 less than gami, the "posterior SNR"
             which is the noisy speech power divided by the noise power. This is
             clipped to a min of (pp.gn-1), smoothed using a factor "a" which corresponds to a
             time-constant of pp.ta and then clipped to a minimum of pp.xn. The
             previous value is taken to be pp.xb*xu where xu is the ratio of the
             estimated speech amplitude squared to the noise power.
             In addition it is possible to specify parameters for the noise estimation
             algorithm
             which implements reference [3] or [7] according to the setting of pp.ne
             Minimum statistics noise estimate [3]: pp.ne=0 
             pp.taca         (11): smoothing time constant for alpha_c [0.0449 seconds]
             pp.tamax        (3): max smoothing time constant [0.392 seconds]
             pp.taminh       (3): min smoothing time constant (upper limit) [0.0133 seconds]
             pp.tpfall       (12): time constant for P to fall [0.064 seconds]
             pp.tbmax        (20): max smoothing time constant [0.0717 seconds]
             pp.qeqmin       (23): minimum value of Qeq [2]
             pp.qeqmax       max value of Qeq per frame [14]
             pp.av           (23)+13 lines: fudge factor for bc calculation  [2.12]
             pp.td           time to take minimum over [1.536 seconds]
             pp.nu           number of subwindows to use [3]
             pp.qith         Q-inverse thresholds to select maximum noise slope [0.03 0.05
             0.06 Inf ]
             pp.nsmdb        corresponding noise slope thresholds in dB/second   [47 31.4 15.7
             4.1]
             MMSE noise estimate [7]: pp.ne=1 
             pp.tax         smoothing time constant for noise power estimate [0.0717
             seconds](8)
             pp.tap         smoothing time constant for smoothed speech prob [0.152
             seconds](23)
             pp.psthr       threshold for smoothed speech probability [0.99] (24)
             pp.pnsaf       noise probability safety value [0.01] (24)
             pp.pspri       prior speech probability [0.5] (18)
             pp.asnr        active SNR in dB [15] (18)
             pp.psini       initial speech probability [0.5] (23)
             pp.tavini      assumed speech absent time at start [0.064 seconds]
             If convenient, you can call specsub in chunks of arbitrary size. Thus the
             following are equivalent:
             (a) y=ssubmmse(s,fs);
             (b) [y1,z]=ssubmmse(s(1:1000),fs);
             [y2,z]=ssubmmse(s(1001:2000),z);
             y3=ssubmmse(s(2001:end),z);
             y=[y1; y2; y3];
             If the number of output arguments is either 2 or 5, the last partial frame of
             samples will
             be retained for overlap adding with the output from the next call to ssubmmse().
             See also specsub() for an alternative gain function
             Refs:
             [1] Ephraim, Y. &amp; Malah, D.
             Speech enhancement using a minimum-mean square error short-time spectral
             amplitude estimator
             IEEE Trans Acoustics Speech and Signal Processing, 32(6):1109-1121, Dec 1984
             [2] Ephraim, Y. &amp; Malah, D.
             Speech enhancement using a minimum mean-square error log-spectral amplitude
             estimator
             IEEE Trans Acoustics Speech and Signal Processing, 33(2):443-445, Apr 1985
             [3] Rainer Martin.
             Noise power spectral density estimation based on optimal smoothing and minimum
             statistics.
             IEEE Trans. Speech and Audio Processing, 9(5):504-512, July 2001.
             [4] O. Cappe.
             Elimination of the musical noise phenomenon with the ephraim and malah noise
             suppressor.
             IEEE Trans Speech Audio Processing, 2 (2): 345?349, Apr. 1994. doi:
             10.1109/89.279283.
             [5] J. Erkelens, J. Jensen, and R. Heusdens.
             A data-driven approach to optimizing spectral speech enhancement methods for
             various error criteria.
             Speech Communication, 49: 530?541, 2007. doi: 10.1016/j.specom.2006.06.012.
             [6] R. Martin.
             Statistical methods for the enhancement of noisy speech.
             In J. Benesty, S. Makino, and J. Chen, editors,
             Speech Enhancement, chapter 3, pages 43?64. Springer-Verlag, 2005.
             [7] Gerkmann, T. &amp; Hendriks, R. C.
             Unbiased MMSE-Based Noise Power Estimation With Low Complexity and Low Tracking
             Delay
             IEEE Trans Audio, Speech, Language Processing, 2012, 20, 1383-1393
             </remarks>
             <param name="si">Input argument #1</param>
             <param name="fsz">Input argument #2</param>
             <returns>An MWArray containing the first output argument.</returns>
            
        </member>
        <member name="M:FilterLib.FilterClass.ssubmmse(MathWorks.MATLAB.NET.Arrays.MWArray,MathWorks.MATLAB.NET.Arrays.MWArray,MathWorks.MATLAB.NET.Arrays.MWArray)">
             <summary>
             Provides a single output, 3-input MWArrayinterface to the ssubmmse MATLAB
             function.
             </summary>
             <remarks>
             M-Documentation:
             SSUBMMSE performs speech enhancement using mmse estimate of spectral amplitude or
             log amplitude [SS,ZO]=(S,FSZ,P)
             Usage: y=ssubmmse(x,fs);      enhance the speech using default parameters
             Inputs:
             si      input speech signal
             fsz     sample frequency in Hz
             Alternatively, the input state from a previous call (see below)
             pp      algorithm parameters [optional]
             Outputs:
             ss        output enhanced speech
             gg(t,f,i) selected time-frequency values (see pp.tf below)
             tt        centre of frames (in seconds)
             ff        centre of frequency bins (in Hz)
             zo        output state (or the 2nd argument if gg,tt,ff are omitted)
             The algorithm operation is controlled by a small number of parameters:
             pp.of             overlap factor = (fft length)/(frame increment) [2]
             pp.ti             desired frame increment [0.016 seconds]
             pp.ri             set to 1 to round ti to the nearest power of 2 samples [0]
             pp.ta             time const for smoothing SNR estimate [0.396 seconds]
             pp.gx             maximum posterior SNR as a power ratio [1000 = +30dB]
             pp.gn             min posterior SNR as a power ratio when estimating prior SNR [1
             = 0dB]
             pp.gz             min posterior SNR as a power ratio [0.001 = -30dB]
             pp.xn             minimum prior SNR [0]
             pp.xb             bias compensation factor for prior SNR [1]
             pp.lg             MMSE target: 0=amplitude, 1=log amplitude [1]
             pp.ne             noise estimation: 0=min statistics, 1=MMSE [0]
             pp.bt             threshold for binary gain or -1 for continuous gain [-1]
             pp.mx             input mixture gain [0]
             pp.rf             round output signal to an exact number of frames [0]
             pp.tf             selects time-frequency planes to output in the gg() variable
             ['g']
             'i' = input power spectrum
             'I' = input complex spectrum
             'n' = noise power spectrum
             'z' = "posterior" SNR (i.e. (S+N)/N )
             'x' = "prior" SNR (i.e. S/N )
             'g' = gain
             'o' = output power spectrum
             'O' = output complex spectrum
             The applied gain is mx+(1-mx)*optgain where optgain is calculated according to
             [1] or [2].
             If pp.bt>=0 then optgain is first thresholded with pp.bt to produce a binary gain
             0 or 1.
             The default parameters implement the original algorithm in [1,2].
             Several parameters relate to the estimation of xi, the so-called "prior SNR",
             xi=max(a*pp.xb*xu+(1-a)*max(gami-1,pp.gn-1),pp.xn);
             This is estimated as a smoothed version of 1 less than gami, the "posterior SNR"
             which is the noisy speech power divided by the noise power. This is
             clipped to a min of (pp.gn-1), smoothed using a factor "a" which corresponds to a
             time-constant of pp.ta and then clipped to a minimum of pp.xn. The
             previous value is taken to be pp.xb*xu where xu is the ratio of the
             estimated speech amplitude squared to the noise power.
             In addition it is possible to specify parameters for the noise estimation
             algorithm
             which implements reference [3] or [7] according to the setting of pp.ne
             Minimum statistics noise estimate [3]: pp.ne=0 
             pp.taca         (11): smoothing time constant for alpha_c [0.0449 seconds]
             pp.tamax        (3): max smoothing time constant [0.392 seconds]
             pp.taminh       (3): min smoothing time constant (upper limit) [0.0133 seconds]
             pp.tpfall       (12): time constant for P to fall [0.064 seconds]
             pp.tbmax        (20): max smoothing time constant [0.0717 seconds]
             pp.qeqmin       (23): minimum value of Qeq [2]
             pp.qeqmax       max value of Qeq per frame [14]
             pp.av           (23)+13 lines: fudge factor for bc calculation  [2.12]
             pp.td           time to take minimum over [1.536 seconds]
             pp.nu           number of subwindows to use [3]
             pp.qith         Q-inverse thresholds to select maximum noise slope [0.03 0.05
             0.06 Inf ]
             pp.nsmdb        corresponding noise slope thresholds in dB/second   [47 31.4 15.7
             4.1]
             MMSE noise estimate [7]: pp.ne=1 
             pp.tax         smoothing time constant for noise power estimate [0.0717
             seconds](8)
             pp.tap         smoothing time constant for smoothed speech prob [0.152
             seconds](23)
             pp.psthr       threshold for smoothed speech probability [0.99] (24)
             pp.pnsaf       noise probability safety value [0.01] (24)
             pp.pspri       prior speech probability [0.5] (18)
             pp.asnr        active SNR in dB [15] (18)
             pp.psini       initial speech probability [0.5] (23)
             pp.tavini      assumed speech absent time at start [0.064 seconds]
             If convenient, you can call specsub in chunks of arbitrary size. Thus the
             following are equivalent:
             (a) y=ssubmmse(s,fs);
             (b) [y1,z]=ssubmmse(s(1:1000),fs);
             [y2,z]=ssubmmse(s(1001:2000),z);
             y3=ssubmmse(s(2001:end),z);
             y=[y1; y2; y3];
             If the number of output arguments is either 2 or 5, the last partial frame of
             samples will
             be retained for overlap adding with the output from the next call to ssubmmse().
             See also specsub() for an alternative gain function
             Refs:
             [1] Ephraim, Y. &amp; Malah, D.
             Speech enhancement using a minimum-mean square error short-time spectral
             amplitude estimator
             IEEE Trans Acoustics Speech and Signal Processing, 32(6):1109-1121, Dec 1984
             [2] Ephraim, Y. &amp; Malah, D.
             Speech enhancement using a minimum mean-square error log-spectral amplitude
             estimator
             IEEE Trans Acoustics Speech and Signal Processing, 33(2):443-445, Apr 1985
             [3] Rainer Martin.
             Noise power spectral density estimation based on optimal smoothing and minimum
             statistics.
             IEEE Trans. Speech and Audio Processing, 9(5):504-512, July 2001.
             [4] O. Cappe.
             Elimination of the musical noise phenomenon with the ephraim and malah noise
             suppressor.
             IEEE Trans Speech Audio Processing, 2 (2): 345?349, Apr. 1994. doi:
             10.1109/89.279283.
             [5] J. Erkelens, J. Jensen, and R. Heusdens.
             A data-driven approach to optimizing spectral speech enhancement methods for
             various error criteria.
             Speech Communication, 49: 530?541, 2007. doi: 10.1016/j.specom.2006.06.012.
             [6] R. Martin.
             Statistical methods for the enhancement of noisy speech.
             In J. Benesty, S. Makino, and J. Chen, editors,
             Speech Enhancement, chapter 3, pages 43?64. Springer-Verlag, 2005.
             [7] Gerkmann, T. &amp; Hendriks, R. C.
             Unbiased MMSE-Based Noise Power Estimation With Low Complexity and Low Tracking
             Delay
             IEEE Trans Audio, Speech, Language Processing, 2012, 20, 1383-1393
             </remarks>
             <param name="si">Input argument #1</param>
             <param name="fsz">Input argument #2</param>
             <param name="pp">Input argument #3</param>
             <returns>An MWArray containing the first output argument.</returns>
            
        </member>
        <member name="M:FilterLib.FilterClass.ssubmmse(System.Int32)">
             <summary>
             Provides the standard 0-input MWArray interface to the ssubmmse MATLAB function.
             </summary>
             <remarks>
             M-Documentation:
             SSUBMMSE performs speech enhancement using mmse estimate of spectral amplitude or
             log amplitude [SS,ZO]=(S,FSZ,P)
             Usage: y=ssubmmse(x,fs);      enhance the speech using default parameters
             Inputs:
             si      input speech signal
             fsz     sample frequency in Hz
             Alternatively, the input state from a previous call (see below)
             pp      algorithm parameters [optional]
             Outputs:
             ss        output enhanced speech
             gg(t,f,i) selected time-frequency values (see pp.tf below)
             tt        centre of frames (in seconds)
             ff        centre of frequency bins (in Hz)
             zo        output state (or the 2nd argument if gg,tt,ff are omitted)
             The algorithm operation is controlled by a small number of parameters:
             pp.of             overlap factor = (fft length)/(frame increment) [2]
             pp.ti             desired frame increment [0.016 seconds]
             pp.ri             set to 1 to round ti to the nearest power of 2 samples [0]
             pp.ta             time const for smoothing SNR estimate [0.396 seconds]
             pp.gx             maximum posterior SNR as a power ratio [1000 = +30dB]
             pp.gn             min posterior SNR as a power ratio when estimating prior SNR [1
             = 0dB]
             pp.gz             min posterior SNR as a power ratio [0.001 = -30dB]
             pp.xn             minimum prior SNR [0]
             pp.xb             bias compensation factor for prior SNR [1]
             pp.lg             MMSE target: 0=amplitude, 1=log amplitude [1]
             pp.ne             noise estimation: 0=min statistics, 1=MMSE [0]
             pp.bt             threshold for binary gain or -1 for continuous gain [-1]
             pp.mx             input mixture gain [0]
             pp.rf             round output signal to an exact number of frames [0]
             pp.tf             selects time-frequency planes to output in the gg() variable
             ['g']
             'i' = input power spectrum
             'I' = input complex spectrum
             'n' = noise power spectrum
             'z' = "posterior" SNR (i.e. (S+N)/N )
             'x' = "prior" SNR (i.e. S/N )
             'g' = gain
             'o' = output power spectrum
             'O' = output complex spectrum
             The applied gain is mx+(1-mx)*optgain where optgain is calculated according to
             [1] or [2].
             If pp.bt>=0 then optgain is first thresholded with pp.bt to produce a binary gain
             0 or 1.
             The default parameters implement the original algorithm in [1,2].
             Several parameters relate to the estimation of xi, the so-called "prior SNR",
             xi=max(a*pp.xb*xu+(1-a)*max(gami-1,pp.gn-1),pp.xn);
             This is estimated as a smoothed version of 1 less than gami, the "posterior SNR"
             which is the noisy speech power divided by the noise power. This is
             clipped to a min of (pp.gn-1), smoothed using a factor "a" which corresponds to a
             time-constant of pp.ta and then clipped to a minimum of pp.xn. The
             previous value is taken to be pp.xb*xu where xu is the ratio of the
             estimated speech amplitude squared to the noise power.
             In addition it is possible to specify parameters for the noise estimation
             algorithm
             which implements reference [3] or [7] according to the setting of pp.ne
             Minimum statistics noise estimate [3]: pp.ne=0 
             pp.taca         (11): smoothing time constant for alpha_c [0.0449 seconds]
             pp.tamax        (3): max smoothing time constant [0.392 seconds]
             pp.taminh       (3): min smoothing time constant (upper limit) [0.0133 seconds]
             pp.tpfall       (12): time constant for P to fall [0.064 seconds]
             pp.tbmax        (20): max smoothing time constant [0.0717 seconds]
             pp.qeqmin       (23): minimum value of Qeq [2]
             pp.qeqmax       max value of Qeq per frame [14]
             pp.av           (23)+13 lines: fudge factor for bc calculation  [2.12]
             pp.td           time to take minimum over [1.536 seconds]
             pp.nu           number of subwindows to use [3]
             pp.qith         Q-inverse thresholds to select maximum noise slope [0.03 0.05
             0.06 Inf ]
             pp.nsmdb        corresponding noise slope thresholds in dB/second   [47 31.4 15.7
             4.1]
             MMSE noise estimate [7]: pp.ne=1 
             pp.tax         smoothing time constant for noise power estimate [0.0717
             seconds](8)
             pp.tap         smoothing time constant for smoothed speech prob [0.152
             seconds](23)
             pp.psthr       threshold for smoothed speech probability [0.99] (24)
             pp.pnsaf       noise probability safety value [0.01] (24)
             pp.pspri       prior speech probability [0.5] (18)
             pp.asnr        active SNR in dB [15] (18)
             pp.psini       initial speech probability [0.5] (23)
             pp.tavini      assumed speech absent time at start [0.064 seconds]
             If convenient, you can call specsub in chunks of arbitrary size. Thus the
             following are equivalent:
             (a) y=ssubmmse(s,fs);
             (b) [y1,z]=ssubmmse(s(1:1000),fs);
             [y2,z]=ssubmmse(s(1001:2000),z);
             y3=ssubmmse(s(2001:end),z);
             y=[y1; y2; y3];
             If the number of output arguments is either 2 or 5, the last partial frame of
             samples will
             be retained for overlap adding with the output from the next call to ssubmmse().
             See also specsub() for an alternative gain function
             Refs:
             [1] Ephraim, Y. &amp; Malah, D.
             Speech enhancement using a minimum-mean square error short-time spectral
             amplitude estimator
             IEEE Trans Acoustics Speech and Signal Processing, 32(6):1109-1121, Dec 1984
             [2] Ephraim, Y. &amp; Malah, D.
             Speech enhancement using a minimum mean-square error log-spectral amplitude
             estimator
             IEEE Trans Acoustics Speech and Signal Processing, 33(2):443-445, Apr 1985
             [3] Rainer Martin.
             Noise power spectral density estimation based on optimal smoothing and minimum
             statistics.
             IEEE Trans. Speech and Audio Processing, 9(5):504-512, July 2001.
             [4] O. Cappe.
             Elimination of the musical noise phenomenon with the ephraim and malah noise
             suppressor.
             IEEE Trans Speech Audio Processing, 2 (2): 345?349, Apr. 1994. doi:
             10.1109/89.279283.
             [5] J. Erkelens, J. Jensen, and R. Heusdens.
             A data-driven approach to optimizing spectral speech enhancement methods for
             various error criteria.
             Speech Communication, 49: 530?541, 2007. doi: 10.1016/j.specom.2006.06.012.
             [6] R. Martin.
             Statistical methods for the enhancement of noisy speech.
             In J. Benesty, S. Makino, and J. Chen, editors,
             Speech Enhancement, chapter 3, pages 43?64. Springer-Verlag, 2005.
             [7] Gerkmann, T. &amp; Hendriks, R. C.
             Unbiased MMSE-Based Noise Power Estimation With Low Complexity and Low Tracking
             Delay
             IEEE Trans Audio, Speech, Language Processing, 2012, 20, 1383-1393
             </remarks>
             <param name="numArgsOut">The number of output arguments to return.</param>
             <returns>An Array of length "numArgsOut" containing the output
             arguments.</returns>
            
        </member>
        <member name="M:FilterLib.FilterClass.ssubmmse(System.Int32,MathWorks.MATLAB.NET.Arrays.MWArray)">
             <summary>
             Provides the standard 1-input MWArray interface to the ssubmmse MATLAB function.
             </summary>
             <remarks>
             M-Documentation:
             SSUBMMSE performs speech enhancement using mmse estimate of spectral amplitude or
             log amplitude [SS,ZO]=(S,FSZ,P)
             Usage: y=ssubmmse(x,fs);      enhance the speech using default parameters
             Inputs:
             si      input speech signal
             fsz     sample frequency in Hz
             Alternatively, the input state from a previous call (see below)
             pp      algorithm parameters [optional]
             Outputs:
             ss        output enhanced speech
             gg(t,f,i) selected time-frequency values (see pp.tf below)
             tt        centre of frames (in seconds)
             ff        centre of frequency bins (in Hz)
             zo        output state (or the 2nd argument if gg,tt,ff are omitted)
             The algorithm operation is controlled by a small number of parameters:
             pp.of             overlap factor = (fft length)/(frame increment) [2]
             pp.ti             desired frame increment [0.016 seconds]
             pp.ri             set to 1 to round ti to the nearest power of 2 samples [0]
             pp.ta             time const for smoothing SNR estimate [0.396 seconds]
             pp.gx             maximum posterior SNR as a power ratio [1000 = +30dB]
             pp.gn             min posterior SNR as a power ratio when estimating prior SNR [1
             = 0dB]
             pp.gz             min posterior SNR as a power ratio [0.001 = -30dB]
             pp.xn             minimum prior SNR [0]
             pp.xb             bias compensation factor for prior SNR [1]
             pp.lg             MMSE target: 0=amplitude, 1=log amplitude [1]
             pp.ne             noise estimation: 0=min statistics, 1=MMSE [0]
             pp.bt             threshold for binary gain or -1 for continuous gain [-1]
             pp.mx             input mixture gain [0]
             pp.rf             round output signal to an exact number of frames [0]
             pp.tf             selects time-frequency planes to output in the gg() variable
             ['g']
             'i' = input power spectrum
             'I' = input complex spectrum
             'n' = noise power spectrum
             'z' = "posterior" SNR (i.e. (S+N)/N )
             'x' = "prior" SNR (i.e. S/N )
             'g' = gain
             'o' = output power spectrum
             'O' = output complex spectrum
             The applied gain is mx+(1-mx)*optgain where optgain is calculated according to
             [1] or [2].
             If pp.bt>=0 then optgain is first thresholded with pp.bt to produce a binary gain
             0 or 1.
             The default parameters implement the original algorithm in [1,2].
             Several parameters relate to the estimation of xi, the so-called "prior SNR",
             xi=max(a*pp.xb*xu+(1-a)*max(gami-1,pp.gn-1),pp.xn);
             This is estimated as a smoothed version of 1 less than gami, the "posterior SNR"
             which is the noisy speech power divided by the noise power. This is
             clipped to a min of (pp.gn-1), smoothed using a factor "a" which corresponds to a
             time-constant of pp.ta and then clipped to a minimum of pp.xn. The
             previous value is taken to be pp.xb*xu where xu is the ratio of the
             estimated speech amplitude squared to the noise power.
             In addition it is possible to specify parameters for the noise estimation
             algorithm
             which implements reference [3] or [7] according to the setting of pp.ne
             Minimum statistics noise estimate [3]: pp.ne=0 
             pp.taca         (11): smoothing time constant for alpha_c [0.0449 seconds]
             pp.tamax        (3): max smoothing time constant [0.392 seconds]
             pp.taminh       (3): min smoothing time constant (upper limit) [0.0133 seconds]
             pp.tpfall       (12): time constant for P to fall [0.064 seconds]
             pp.tbmax        (20): max smoothing time constant [0.0717 seconds]
             pp.qeqmin       (23): minimum value of Qeq [2]
             pp.qeqmax       max value of Qeq per frame [14]
             pp.av           (23)+13 lines: fudge factor for bc calculation  [2.12]
             pp.td           time to take minimum over [1.536 seconds]
             pp.nu           number of subwindows to use [3]
             pp.qith         Q-inverse thresholds to select maximum noise slope [0.03 0.05
             0.06 Inf ]
             pp.nsmdb        corresponding noise slope thresholds in dB/second   [47 31.4 15.7
             4.1]
             MMSE noise estimate [7]: pp.ne=1 
             pp.tax         smoothing time constant for noise power estimate [0.0717
             seconds](8)
             pp.tap         smoothing time constant for smoothed speech prob [0.152
             seconds](23)
             pp.psthr       threshold for smoothed speech probability [0.99] (24)
             pp.pnsaf       noise probability safety value [0.01] (24)
             pp.pspri       prior speech probability [0.5] (18)
             pp.asnr        active SNR in dB [15] (18)
             pp.psini       initial speech probability [0.5] (23)
             pp.tavini      assumed speech absent time at start [0.064 seconds]
             If convenient, you can call specsub in chunks of arbitrary size. Thus the
             following are equivalent:
             (a) y=ssubmmse(s,fs);
             (b) [y1,z]=ssubmmse(s(1:1000),fs);
             [y2,z]=ssubmmse(s(1001:2000),z);
             y3=ssubmmse(s(2001:end),z);
             y=[y1; y2; y3];
             If the number of output arguments is either 2 or 5, the last partial frame of
             samples will
             be retained for overlap adding with the output from the next call to ssubmmse().
             See also specsub() for an alternative gain function
             Refs:
             [1] Ephraim, Y. &amp; Malah, D.
             Speech enhancement using a minimum-mean square error short-time spectral
             amplitude estimator
             IEEE Trans Acoustics Speech and Signal Processing, 32(6):1109-1121, Dec 1984
             [2] Ephraim, Y. &amp; Malah, D.
             Speech enhancement using a minimum mean-square error log-spectral amplitude
             estimator
             IEEE Trans Acoustics Speech and Signal Processing, 33(2):443-445, Apr 1985
             [3] Rainer Martin.
             Noise power spectral density estimation based on optimal smoothing and minimum
             statistics.
             IEEE Trans. Speech and Audio Processing, 9(5):504-512, July 2001.
             [4] O. Cappe.
             Elimination of the musical noise phenomenon with the ephraim and malah noise
             suppressor.
             IEEE Trans Speech Audio Processing, 2 (2): 345?349, Apr. 1994. doi:
             10.1109/89.279283.
             [5] J. Erkelens, J. Jensen, and R. Heusdens.
             A data-driven approach to optimizing spectral speech enhancement methods for
             various error criteria.
             Speech Communication, 49: 530?541, 2007. doi: 10.1016/j.specom.2006.06.012.
             [6] R. Martin.
             Statistical methods for the enhancement of noisy speech.
             In J. Benesty, S. Makino, and J. Chen, editors,
             Speech Enhancement, chapter 3, pages 43?64. Springer-Verlag, 2005.
             [7] Gerkmann, T. &amp; Hendriks, R. C.
             Unbiased MMSE-Based Noise Power Estimation With Low Complexity and Low Tracking
             Delay
             IEEE Trans Audio, Speech, Language Processing, 2012, 20, 1383-1393
             </remarks>
             <param name="numArgsOut">The number of output arguments to return.</param>
             <param name="si">Input argument #1</param>
             <returns>An Array of length "numArgsOut" containing the output
             arguments.</returns>
            
        </member>
        <member name="M:FilterLib.FilterClass.ssubmmse(System.Int32,MathWorks.MATLAB.NET.Arrays.MWArray,MathWorks.MATLAB.NET.Arrays.MWArray)">
             <summary>
             Provides the standard 2-input MWArray interface to the ssubmmse MATLAB function.
             </summary>
             <remarks>
             M-Documentation:
             SSUBMMSE performs speech enhancement using mmse estimate of spectral amplitude or
             log amplitude [SS,ZO]=(S,FSZ,P)
             Usage: y=ssubmmse(x,fs);      enhance the speech using default parameters
             Inputs:
             si      input speech signal
             fsz     sample frequency in Hz
             Alternatively, the input state from a previous call (see below)
             pp      algorithm parameters [optional]
             Outputs:
             ss        output enhanced speech
             gg(t,f,i) selected time-frequency values (see pp.tf below)
             tt        centre of frames (in seconds)
             ff        centre of frequency bins (in Hz)
             zo        output state (or the 2nd argument if gg,tt,ff are omitted)
             The algorithm operation is controlled by a small number of parameters:
             pp.of             overlap factor = (fft length)/(frame increment) [2]
             pp.ti             desired frame increment [0.016 seconds]
             pp.ri             set to 1 to round ti to the nearest power of 2 samples [0]
             pp.ta             time const for smoothing SNR estimate [0.396 seconds]
             pp.gx             maximum posterior SNR as a power ratio [1000 = +30dB]
             pp.gn             min posterior SNR as a power ratio when estimating prior SNR [1
             = 0dB]
             pp.gz             min posterior SNR as a power ratio [0.001 = -30dB]
             pp.xn             minimum prior SNR [0]
             pp.xb             bias compensation factor for prior SNR [1]
             pp.lg             MMSE target: 0=amplitude, 1=log amplitude [1]
             pp.ne             noise estimation: 0=min statistics, 1=MMSE [0]
             pp.bt             threshold for binary gain or -1 for continuous gain [-1]
             pp.mx             input mixture gain [0]
             pp.rf             round output signal to an exact number of frames [0]
             pp.tf             selects time-frequency planes to output in the gg() variable
             ['g']
             'i' = input power spectrum
             'I' = input complex spectrum
             'n' = noise power spectrum
             'z' = "posterior" SNR (i.e. (S+N)/N )
             'x' = "prior" SNR (i.e. S/N )
             'g' = gain
             'o' = output power spectrum
             'O' = output complex spectrum
             The applied gain is mx+(1-mx)*optgain where optgain is calculated according to
             [1] or [2].
             If pp.bt>=0 then optgain is first thresholded with pp.bt to produce a binary gain
             0 or 1.
             The default parameters implement the original algorithm in [1,2].
             Several parameters relate to the estimation of xi, the so-called "prior SNR",
             xi=max(a*pp.xb*xu+(1-a)*max(gami-1,pp.gn-1),pp.xn);
             This is estimated as a smoothed version of 1 less than gami, the "posterior SNR"
             which is the noisy speech power divided by the noise power. This is
             clipped to a min of (pp.gn-1), smoothed using a factor "a" which corresponds to a
             time-constant of pp.ta and then clipped to a minimum of pp.xn. The
             previous value is taken to be pp.xb*xu where xu is the ratio of the
             estimated speech amplitude squared to the noise power.
             In addition it is possible to specify parameters for the noise estimation
             algorithm
             which implements reference [3] or [7] according to the setting of pp.ne
             Minimum statistics noise estimate [3]: pp.ne=0 
             pp.taca         (11): smoothing time constant for alpha_c [0.0449 seconds]
             pp.tamax        (3): max smoothing time constant [0.392 seconds]
             pp.taminh       (3): min smoothing time constant (upper limit) [0.0133 seconds]
             pp.tpfall       (12): time constant for P to fall [0.064 seconds]
             pp.tbmax        (20): max smoothing time constant [0.0717 seconds]
             pp.qeqmin       (23): minimum value of Qeq [2]
             pp.qeqmax       max value of Qeq per frame [14]
             pp.av           (23)+13 lines: fudge factor for bc calculation  [2.12]
             pp.td           time to take minimum over [1.536 seconds]
             pp.nu           number of subwindows to use [3]
             pp.qith         Q-inverse thresholds to select maximum noise slope [0.03 0.05
             0.06 Inf ]
             pp.nsmdb        corresponding noise slope thresholds in dB/second   [47 31.4 15.7
             4.1]
             MMSE noise estimate [7]: pp.ne=1 
             pp.tax         smoothing time constant for noise power estimate [0.0717
             seconds](8)
             pp.tap         smoothing time constant for smoothed speech prob [0.152
             seconds](23)
             pp.psthr       threshold for smoothed speech probability [0.99] (24)
             pp.pnsaf       noise probability safety value [0.01] (24)
             pp.pspri       prior speech probability [0.5] (18)
             pp.asnr        active SNR in dB [15] (18)
             pp.psini       initial speech probability [0.5] (23)
             pp.tavini      assumed speech absent time at start [0.064 seconds]
             If convenient, you can call specsub in chunks of arbitrary size. Thus the
             following are equivalent:
             (a) y=ssubmmse(s,fs);
             (b) [y1,z]=ssubmmse(s(1:1000),fs);
             [y2,z]=ssubmmse(s(1001:2000),z);
             y3=ssubmmse(s(2001:end),z);
             y=[y1; y2; y3];
             If the number of output arguments is either 2 or 5, the last partial frame of
             samples will
             be retained for overlap adding with the output from the next call to ssubmmse().
             See also specsub() for an alternative gain function
             Refs:
             [1] Ephraim, Y. &amp; Malah, D.
             Speech enhancement using a minimum-mean square error short-time spectral
             amplitude estimator
             IEEE Trans Acoustics Speech and Signal Processing, 32(6):1109-1121, Dec 1984
             [2] Ephraim, Y. &amp; Malah, D.
             Speech enhancement using a minimum mean-square error log-spectral amplitude
             estimator
             IEEE Trans Acoustics Speech and Signal Processing, 33(2):443-445, Apr 1985
             [3] Rainer Martin.
             Noise power spectral density estimation based on optimal smoothing and minimum
             statistics.
             IEEE Trans. Speech and Audio Processing, 9(5):504-512, July 2001.
             [4] O. Cappe.
             Elimination of the musical noise phenomenon with the ephraim and malah noise
             suppressor.
             IEEE Trans Speech Audio Processing, 2 (2): 345?349, Apr. 1994. doi:
             10.1109/89.279283.
             [5] J. Erkelens, J. Jensen, and R. Heusdens.
             A data-driven approach to optimizing spectral speech enhancement methods for
             various error criteria.
             Speech Communication, 49: 530?541, 2007. doi: 10.1016/j.specom.2006.06.012.
             [6] R. Martin.
             Statistical methods for the enhancement of noisy speech.
             In J. Benesty, S. Makino, and J. Chen, editors,
             Speech Enhancement, chapter 3, pages 43?64. Springer-Verlag, 2005.
             [7] Gerkmann, T. &amp; Hendriks, R. C.
             Unbiased MMSE-Based Noise Power Estimation With Low Complexity and Low Tracking
             Delay
             IEEE Trans Audio, Speech, Language Processing, 2012, 20, 1383-1393
             </remarks>
             <param name="numArgsOut">The number of output arguments to return.</param>
             <param name="si">Input argument #1</param>
             <param name="fsz">Input argument #2</param>
             <returns>An Array of length "numArgsOut" containing the output
             arguments.</returns>
            
        </member>
        <member name="M:FilterLib.FilterClass.ssubmmse(System.Int32,MathWorks.MATLAB.NET.Arrays.MWArray,MathWorks.MATLAB.NET.Arrays.MWArray,MathWorks.MATLAB.NET.Arrays.MWArray)">
             <summary>
             Provides the standard 3-input MWArray interface to the ssubmmse MATLAB function.
             </summary>
             <remarks>
             M-Documentation:
             SSUBMMSE performs speech enhancement using mmse estimate of spectral amplitude or
             log amplitude [SS,ZO]=(S,FSZ,P)
             Usage: y=ssubmmse(x,fs);      enhance the speech using default parameters
             Inputs:
             si      input speech signal
             fsz     sample frequency in Hz
             Alternatively, the input state from a previous call (see below)
             pp      algorithm parameters [optional]
             Outputs:
             ss        output enhanced speech
             gg(t,f,i) selected time-frequency values (see pp.tf below)
             tt        centre of frames (in seconds)
             ff        centre of frequency bins (in Hz)
             zo        output state (or the 2nd argument if gg,tt,ff are omitted)
             The algorithm operation is controlled by a small number of parameters:
             pp.of             overlap factor = (fft length)/(frame increment) [2]
             pp.ti             desired frame increment [0.016 seconds]
             pp.ri             set to 1 to round ti to the nearest power of 2 samples [0]
             pp.ta             time const for smoothing SNR estimate [0.396 seconds]
             pp.gx             maximum posterior SNR as a power ratio [1000 = +30dB]
             pp.gn             min posterior SNR as a power ratio when estimating prior SNR [1
             = 0dB]
             pp.gz             min posterior SNR as a power ratio [0.001 = -30dB]
             pp.xn             minimum prior SNR [0]
             pp.xb             bias compensation factor for prior SNR [1]
             pp.lg             MMSE target: 0=amplitude, 1=log amplitude [1]
             pp.ne             noise estimation: 0=min statistics, 1=MMSE [0]
             pp.bt             threshold for binary gain or -1 for continuous gain [-1]
             pp.mx             input mixture gain [0]
             pp.rf             round output signal to an exact number of frames [0]
             pp.tf             selects time-frequency planes to output in the gg() variable
             ['g']
             'i' = input power spectrum
             'I' = input complex spectrum
             'n' = noise power spectrum
             'z' = "posterior" SNR (i.e. (S+N)/N )
             'x' = "prior" SNR (i.e. S/N )
             'g' = gain
             'o' = output power spectrum
             'O' = output complex spectrum
             The applied gain is mx+(1-mx)*optgain where optgain is calculated according to
             [1] or [2].
             If pp.bt>=0 then optgain is first thresholded with pp.bt to produce a binary gain
             0 or 1.
             The default parameters implement the original algorithm in [1,2].
             Several parameters relate to the estimation of xi, the so-called "prior SNR",
             xi=max(a*pp.xb*xu+(1-a)*max(gami-1,pp.gn-1),pp.xn);
             This is estimated as a smoothed version of 1 less than gami, the "posterior SNR"
             which is the noisy speech power divided by the noise power. This is
             clipped to a min of (pp.gn-1), smoothed using a factor "a" which corresponds to a
             time-constant of pp.ta and then clipped to a minimum of pp.xn. The
             previous value is taken to be pp.xb*xu where xu is the ratio of the
             estimated speech amplitude squared to the noise power.
             In addition it is possible to specify parameters for the noise estimation
             algorithm
             which implements reference [3] or [7] according to the setting of pp.ne
             Minimum statistics noise estimate [3]: pp.ne=0 
             pp.taca         (11): smoothing time constant for alpha_c [0.0449 seconds]
             pp.tamax        (3): max smoothing time constant [0.392 seconds]
             pp.taminh       (3): min smoothing time constant (upper limit) [0.0133 seconds]
             pp.tpfall       (12): time constant for P to fall [0.064 seconds]
             pp.tbmax        (20): max smoothing time constant [0.0717 seconds]
             pp.qeqmin       (23): minimum value of Qeq [2]
             pp.qeqmax       max value of Qeq per frame [14]
             pp.av           (23)+13 lines: fudge factor for bc calculation  [2.12]
             pp.td           time to take minimum over [1.536 seconds]
             pp.nu           number of subwindows to use [3]
             pp.qith         Q-inverse thresholds to select maximum noise slope [0.03 0.05
             0.06 Inf ]
             pp.nsmdb        corresponding noise slope thresholds in dB/second   [47 31.4 15.7
             4.1]
             MMSE noise estimate [7]: pp.ne=1 
             pp.tax         smoothing time constant for noise power estimate [0.0717
             seconds](8)
             pp.tap         smoothing time constant for smoothed speech prob [0.152
             seconds](23)
             pp.psthr       threshold for smoothed speech probability [0.99] (24)
             pp.pnsaf       noise probability safety value [0.01] (24)
             pp.pspri       prior speech probability [0.5] (18)
             pp.asnr        active SNR in dB [15] (18)
             pp.psini       initial speech probability [0.5] (23)
             pp.tavini      assumed speech absent time at start [0.064 seconds]
             If convenient, you can call specsub in chunks of arbitrary size. Thus the
             following are equivalent:
             (a) y=ssubmmse(s,fs);
             (b) [y1,z]=ssubmmse(s(1:1000),fs);
             [y2,z]=ssubmmse(s(1001:2000),z);
             y3=ssubmmse(s(2001:end),z);
             y=[y1; y2; y3];
             If the number of output arguments is either 2 or 5, the last partial frame of
             samples will
             be retained for overlap adding with the output from the next call to ssubmmse().
             See also specsub() for an alternative gain function
             Refs:
             [1] Ephraim, Y. &amp; Malah, D.
             Speech enhancement using a minimum-mean square error short-time spectral
             amplitude estimator
             IEEE Trans Acoustics Speech and Signal Processing, 32(6):1109-1121, Dec 1984
             [2] Ephraim, Y. &amp; Malah, D.
             Speech enhancement using a minimum mean-square error log-spectral amplitude
             estimator
             IEEE Trans Acoustics Speech and Signal Processing, 33(2):443-445, Apr 1985
             [3] Rainer Martin.
             Noise power spectral density estimation based on optimal smoothing and minimum
             statistics.
             IEEE Trans. Speech and Audio Processing, 9(5):504-512, July 2001.
             [4] O. Cappe.
             Elimination of the musical noise phenomenon with the ephraim and malah noise
             suppressor.
             IEEE Trans Speech Audio Processing, 2 (2): 345?349, Apr. 1994. doi:
             10.1109/89.279283.
             [5] J. Erkelens, J. Jensen, and R. Heusdens.
             A data-driven approach to optimizing spectral speech enhancement methods for
             various error criteria.
             Speech Communication, 49: 530?541, 2007. doi: 10.1016/j.specom.2006.06.012.
             [6] R. Martin.
             Statistical methods for the enhancement of noisy speech.
             In J. Benesty, S. Makino, and J. Chen, editors,
             Speech Enhancement, chapter 3, pages 43?64. Springer-Verlag, 2005.
             [7] Gerkmann, T. &amp; Hendriks, R. C.
             Unbiased MMSE-Based Noise Power Estimation With Low Complexity and Low Tracking
             Delay
             IEEE Trans Audio, Speech, Language Processing, 2012, 20, 1383-1393
             </remarks>
             <param name="numArgsOut">The number of output arguments to return.</param>
             <param name="si">Input argument #1</param>
             <param name="fsz">Input argument #2</param>
             <param name="pp">Input argument #3</param>
             <returns>An Array of length "numArgsOut" containing the output
             arguments.</returns>
            
        </member>
        <member name="M:FilterLib.FilterClass.ssubmmse(System.Int32,MathWorks.MATLAB.NET.Arrays.MWArray[]@,MathWorks.MATLAB.NET.Arrays.MWArray[])">
             <summary>
             Provides an interface for the ssubmmse function in which the input and output
             arguments are specified as an array of MWArrays.
             </summary>
             <remarks>
             This method will allocate and return by reference the output argument
             array.<newpara></newpara>
             M-Documentation:
             SSUBMMSE performs speech enhancement using mmse estimate of spectral amplitude or
             log amplitude [SS,ZO]=(S,FSZ,P)
             Usage: y=ssubmmse(x,fs);      enhance the speech using default parameters
             Inputs:
             si      input speech signal
             fsz     sample frequency in Hz
             Alternatively, the input state from a previous call (see below)
             pp      algorithm parameters [optional]
             Outputs:
             ss        output enhanced speech
             gg(t,f,i) selected time-frequency values (see pp.tf below)
             tt        centre of frames (in seconds)
             ff        centre of frequency bins (in Hz)
             zo        output state (or the 2nd argument if gg,tt,ff are omitted)
             The algorithm operation is controlled by a small number of parameters:
             pp.of             overlap factor = (fft length)/(frame increment) [2]
             pp.ti             desired frame increment [0.016 seconds]
             pp.ri             set to 1 to round ti to the nearest power of 2 samples [0]
             pp.ta             time const for smoothing SNR estimate [0.396 seconds]
             pp.gx             maximum posterior SNR as a power ratio [1000 = +30dB]
             pp.gn             min posterior SNR as a power ratio when estimating prior SNR [1
             = 0dB]
             pp.gz             min posterior SNR as a power ratio [0.001 = -30dB]
             pp.xn             minimum prior SNR [0]
             pp.xb             bias compensation factor for prior SNR [1]
             pp.lg             MMSE target: 0=amplitude, 1=log amplitude [1]
             pp.ne             noise estimation: 0=min statistics, 1=MMSE [0]
             pp.bt             threshold for binary gain or -1 for continuous gain [-1]
             pp.mx             input mixture gain [0]
             pp.rf             round output signal to an exact number of frames [0]
             pp.tf             selects time-frequency planes to output in the gg() variable
             ['g']
             'i' = input power spectrum
             'I' = input complex spectrum
             'n' = noise power spectrum
             'z' = "posterior" SNR (i.e. (S+N)/N )
             'x' = "prior" SNR (i.e. S/N )
             'g' = gain
             'o' = output power spectrum
             'O' = output complex spectrum
             The applied gain is mx+(1-mx)*optgain where optgain is calculated according to
             [1] or [2].
             If pp.bt>=0 then optgain is first thresholded with pp.bt to produce a binary gain
             0 or 1.
             The default parameters implement the original algorithm in [1,2].
             Several parameters relate to the estimation of xi, the so-called "prior SNR",
             xi=max(a*pp.xb*xu+(1-a)*max(gami-1,pp.gn-1),pp.xn);
             This is estimated as a smoothed version of 1 less than gami, the "posterior SNR"
             which is the noisy speech power divided by the noise power. This is
             clipped to a min of (pp.gn-1), smoothed using a factor "a" which corresponds to a
             time-constant of pp.ta and then clipped to a minimum of pp.xn. The
             previous value is taken to be pp.xb*xu where xu is the ratio of the
             estimated speech amplitude squared to the noise power.
             In addition it is possible to specify parameters for the noise estimation
             algorithm
             which implements reference [3] or [7] according to the setting of pp.ne
             Minimum statistics noise estimate [3]: pp.ne=0 
             pp.taca         (11): smoothing time constant for alpha_c [0.0449 seconds]
             pp.tamax        (3): max smoothing time constant [0.392 seconds]
             pp.taminh       (3): min smoothing time constant (upper limit) [0.0133 seconds]
             pp.tpfall       (12): time constant for P to fall [0.064 seconds]
             pp.tbmax        (20): max smoothing time constant [0.0717 seconds]
             pp.qeqmin       (23): minimum value of Qeq [2]
             pp.qeqmax       max value of Qeq per frame [14]
             pp.av           (23)+13 lines: fudge factor for bc calculation  [2.12]
             pp.td           time to take minimum over [1.536 seconds]
             pp.nu           number of subwindows to use [3]
             pp.qith         Q-inverse thresholds to select maximum noise slope [0.03 0.05
             0.06 Inf ]
             pp.nsmdb        corresponding noise slope thresholds in dB/second   [47 31.4 15.7
             4.1]
             MMSE noise estimate [7]: pp.ne=1 
             pp.tax         smoothing time constant for noise power estimate [0.0717
             seconds](8)
             pp.tap         smoothing time constant for smoothed speech prob [0.152
             seconds](23)
             pp.psthr       threshold for smoothed speech probability [0.99] (24)
             pp.pnsaf       noise probability safety value [0.01] (24)
             pp.pspri       prior speech probability [0.5] (18)
             pp.asnr        active SNR in dB [15] (18)
             pp.psini       initial speech probability [0.5] (23)
             pp.tavini      assumed speech absent time at start [0.064 seconds]
             If convenient, you can call specsub in chunks of arbitrary size. Thus the
             following are equivalent:
             (a) y=ssubmmse(s,fs);
             (b) [y1,z]=ssubmmse(s(1:1000),fs);
             [y2,z]=ssubmmse(s(1001:2000),z);
             y3=ssubmmse(s(2001:end),z);
             y=[y1; y2; y3];
             If the number of output arguments is either 2 or 5, the last partial frame of
             samples will
             be retained for overlap adding with the output from the next call to ssubmmse().
             See also specsub() for an alternative gain function
             Refs:
             [1] Ephraim, Y. &amp; Malah, D.
             Speech enhancement using a minimum-mean square error short-time spectral
             amplitude estimator
             IEEE Trans Acoustics Speech and Signal Processing, 32(6):1109-1121, Dec 1984
             [2] Ephraim, Y. &amp; Malah, D.
             Speech enhancement using a minimum mean-square error log-spectral amplitude
             estimator
             IEEE Trans Acoustics Speech and Signal Processing, 33(2):443-445, Apr 1985
             [3] Rainer Martin.
             Noise power spectral density estimation based on optimal smoothing and minimum
             statistics.
             IEEE Trans. Speech and Audio Processing, 9(5):504-512, July 2001.
             [4] O. Cappe.
             Elimination of the musical noise phenomenon with the ephraim and malah noise
             suppressor.
             IEEE Trans Speech Audio Processing, 2 (2): 345?349, Apr. 1994. doi:
             10.1109/89.279283.
             [5] J. Erkelens, J. Jensen, and R. Heusdens.
             A data-driven approach to optimizing spectral speech enhancement methods for
             various error criteria.
             Speech Communication, 49: 530?541, 2007. doi: 10.1016/j.specom.2006.06.012.
             [6] R. Martin.
             Statistical methods for the enhancement of noisy speech.
             In J. Benesty, S. Makino, and J. Chen, editors,
             Speech Enhancement, chapter 3, pages 43?64. Springer-Verlag, 2005.
             [7] Gerkmann, T. &amp; Hendriks, R. C.
             Unbiased MMSE-Based Noise Power Estimation With Low Complexity and Low Tracking
             Delay
             IEEE Trans Audio, Speech, Language Processing, 2012, 20, 1383-1393
             </remarks>
             <param name="numArgsOut">The number of output arguments to return</param>
             <param name= "argsOut">Array of MWArray output arguments</param>
             <param name= "argsIn">Array of MWArray input arguments</param>
            
        </member>
        <member name="M:FilterLib.FilterClass.WaitForFiguresToDie">
             <summary>
             This method will cause a MATLAB figure window to behave as a modal dialog box.
             The method will not return until all the figure windows associated with this
             component have been closed.
             </summary>
             <remarks>
             An application should only call this method when required to keep the
             MATLAB figure window from disappearing.  Other techniques, such as calling
             Console.ReadLine() from the application should be considered where
             possible.</remarks>
            
        </member>
    </members>
</doc>
